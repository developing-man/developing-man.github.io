{"meta":{"title":"丁满博客 - Hexo博客","subtitle":"","description":"","author":"胖胖的丁满","url":"https://devloperhu.gitee.io","root":"/"},"pages":[{"title":"所有分类","date":"2021-02-15T17:10:21.000Z","updated":"2021-02-15T17:51:38.948Z","comments":true,"path":"categories/index.html","permalink":"https://devloperhu.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-02-15T17:23:22.000Z","updated":"2022-03-12T10:28:20.254Z","comments":true,"path":"about/index.html","permalink":"https://devloperhu.gitee.io/about/index.html","excerpt":"","text":"95年码农，湖北黄冈，毕业于华中农业大学机械化及其自动化专业。 毕业后在郑州宇通客车工作两年，职位夹具设计师，负责车身中高精度夹具设计。 后因个人兴趣及对职业的长久思考，转行Java开发。 经历四个月的培训，现已有三Java开发经验，坐标上海。 未来目标：继续提升个人技术，积累经验向架构师进发。"},{"title":"留言板","date":"2021-02-15T17:46:47.000Z","updated":"2021-03-07T10:35:39.997Z","comments":true,"path":"guestbook/index.html","permalink":"https://devloperhu.gitee.io/guestbook/index.html","excerpt":"","text":"欢迎留言！"},{"title":"所有标签","date":"2021-02-15T17:30:07.000Z","updated":"2021-02-15T17:51:47.351Z","comments":true,"path":"tags/index.html","permalink":"https://devloperhu.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring之属性注入","slug":"Spring之属性注入","date":"2021-12-19T07:43:07.000Z","updated":"2022-02-27T13:56:04.032Z","comments":true,"path":"posts/39762.html","link":"","permalink":"https://devloperhu.gitee.io/posts/39762.html","excerpt":"","text":"依赖注入的方式spring的依赖注入方式分为分别是基于构造方法和基于setter。以下是Spring官网原话： 1DI exists in two major variants: Constructor-based dependency injection and Setter-based dependency injection. DI存在两个主要变体：基于构造函数的依赖注入和基于Setter的依赖注入。 而装配方式又分为手动装配和自动装配，但是不管是手动装配还是自动装配都是基于这两种方式或者变体方式来的。有的注入方式就不是这两种，而是这两种其中一种的变体方式；比如在一个类的属性上面加@Autowired，这种方式注入属性的方式就是利用了java的反射知识,@Autowired这种注入的方式是setter注入方式的一种变体 手动装配在spring应用程序当中假设你的A类依赖了B类. 需要在A类当中提供一个B类的属性, 再加上setter, 继而在xml当中配置、描述一下这两个类之间的依赖关系. 如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；这种由程序员自己配置、描述好依赖关系的写法叫做手动装配。 代码演示123456789101112131415161718192021222324252627282930class B &#123;&#125;public class A &#123; B b; // 测试set注入 // public void setB(B b) &#123; // this.b = b; // &#125; // 测试构造方法注入 public A(B b) &#123; super(); this.b = b; &#125; public B getB() &#123; System.out.println(&quot;获取的B对象：&quot; + b); return b; &#125;&#125;class C &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;); context.getBean(A.class).getB(); &#125;&#125; 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;a&quot; class=&quot;com.spring.autowired.A&quot;&gt; &lt;!-- set注入 --&gt; &lt;!-- &lt;property name=&quot;b&quot; ref=&quot;b&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- 构造方法注入 --&gt; &lt;constructor-arg name=&quot;b&quot; ref=&quot;b&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;b&quot; class=&quot;com.spring.autowired.B&quot;/&gt;&lt;/beans&gt; 自动装配自动注入的出现是因为手动装配过于麻烦，比如某个类X当中依赖了10个其他类那么配置文件将会变的特别冗余和臃肿，spring的做法是可以为这个X类提供一种叫做自动装配的模型，无需程序员去手动配置X类的依赖关系。 代码演示123456789101112131415161718192021222324252627282930class D &#123;&#125;public class A &#123; D d; // 测试setter方法注入 public void setD(D d) &#123; this.d = d; &#125; // 测试构造方法注入 public A(D d) &#123; super(); this.d = d; &#125; public D getD() &#123; System.out.println(&quot;获取的D对象：&quot; + d); return d; &#125;&#125;class C &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;); context.getBean(A.class).getD(); &#125;&#125; 自动装配模式 （Autowiring modes） 模式 解释 no （默认）没有自动装配。Bean 引用必须由ref元素定义。对于较大的部署，不建议更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。 byName 按属性名称自动装配。Spring 查找与需要自动装配的属性同名的 bean。例如，如果一个 bean 定义被设置为按名称自动装配并且它包含一个master属性（即它有一个 setMaster(..)方法），Spring 会查找一个名为master的 bean 定义并使用它来设置属性。 byType 如果容器中恰好存在一个属性类型的 bean，则让属性自动装配。如果存在多个，则会引发致命异常，这表明您不能byType为该 bean使用自动装配。如果没有匹配的 bean，则不会发生任何事情（未设置属性）。 constructor 类似于byType但适用于构造函数参数。如果容器中没有一个构造函数参数类型的 bean，则会引发致命错误。 自动注入模式和前面提到的依赖注入方式(setter和构造方法)是两回事，简单说:依赖注入是一个过程，主要通过setter和构造方法以及一些变体的方式完成把对象依赖、或者填充上的这个过程叫做依赖注入，不管手动装配还是自动装配都有这个过程；而自动装配模式是一种完成自动装配依赖的手段体现，每一种模型都使用了不同的技术去查找和填充bean；而从spring官网上面可以看到spring只提出了4中自动装配模式,(第一种是no，表示不使用自动装配.)。 这四个模式分别用一个整型来表示，存在spring的beanDefinition当中，任何一个类默认是no这个装配模式，也就是一个被注解的类默认的装配模型是no也就是手动装配；需要注意的是官网上面说的四种注入模型其中并没有我们熟悉的**@Autowired**，这也再一次说明@Autowired不是自动装配。 假设在TestService类的某个属性上面加上@Autowired之后这个TestService类会不会成了自动装配呢？@Autowired是不是会改变这个类A当中的autowireMode呢？答案是不会的，可以自定义一个spring后置处理器，去取出设置了@Autowired的beanDefinition，然后获取AutowireMode，会发现一直是0。说明这个类不是自动装配，其实这已经能证明@Autowried不是自动装配了。","categories":[],"tags":[]},{"title":"Java日志到Spring日志浅析","slug":"Java日志到Spring日志浅析","date":"2021-12-11T00:52:55.000Z","updated":"2021-12-12T06:20:27.343Z","comments":true,"path":"posts/35037.html","link":"","permalink":"https://devloperhu.gitee.io/posts/35037.html","excerpt":"","text":"前情提要&emsp;&emsp;最近log4j2在安全圈爆出严重漏洞问题，就发觉自己对Java日志体系了解的有点模糊。平时工作只知道复用已有的日志框架，然后打印日志就行，对于为什么会有log4j及slf4j都不太清楚，因此花点时间完善一下这块知识。 日志产品介绍JDK Logging：Java标准库内置的日志包 java.util.logging，以下简称jul。 log4j：一种非常流行的日志框架，最新版本是2.x。 commons-logging：简称jcl，它是一个第三方的日志库，由Apache创建的日志模块。特点是可以挂接不同的日志系统，可以根据配置文件指定挂接的日志系统。默认情况下，jcl自动搜索并使用log4j,如果过没找到log4j,再使用JDK Logging。 123456789101112131415161718192021 // 内部硬编码维护了一个常用log日志全类名数组 private static final String[] classesToDiscover = new String[]&#123; &quot;org.apache.commons.logging.impl.Log4JLogger&quot;, &quot;org.apache.commons.logging.impl.Jdk14Logger&quot;, &quot;org.apache.commons.logging.impl.Jdk13LumberjackLogger&quot;, &quot;org.apache.commons.logging.impl.SimpleLog&quot; &#125;;// 遍历该数组，去获取用户调用的LOG for(int i = 0; i &lt; classesToDiscover.length &amp;&amp; result == null; ++i) &#123; result = this.createLogFromClass(classesToDiscover[i], logCategory, true); &#125; ... try &#123; c = Class.forName(logAdapterClassName, true, currentCL); &#125; catch ( ) &#123; ... &#125; constructor = c.getConstructor(this.logConstructorSignature); Object o = constructor.newInstance(params); 前面介绍了Commons Logging和Log4j，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。还有SLF4J(The Simple Logging Facade for Java)和Logback，其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。 SLF4J提供了绑定器与各类实现它的日志框架结合进行使用： 1234567891011121314151617181920&lt;!-- logback-绑定器 包含了核心和slf4j 以及logback的绑定器 三个 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j-log4j1 绑定器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.32&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log4j2-slf4j-impl 绑定器 绑定log4j2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt;&lt;/dependency&gt; SLF4J还提供了桥接器来解决历史日志硬编码问题： 12345678910111213&lt;!-- log4j2桥接器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- log4j-over-slf4j log4j1的桥接器 不能和log4j1的核心共存会有jar冲突问题 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.32&lt;/version&gt;&lt;/dependency&gt; ​ 为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。 spring日志&emsp;&emsp;spring 4.x 及以前版本基本采用jcl，扩展机制根据用户手动依赖的日志产品进行挂接，改变spring默认日志框架。spring 5.x 版本后，自己搞了一个spring-jcl的module。 spring默认更支持使用log4j，可看源码得知： 123456789101112131415161718192021222324252627282930313233343536373839 // 创建Log时依据用户指定枚举值 public static Log createLog(String name) &#123; switch (logApi) &#123; case LOG4J: return Log4jAdapter.createLog(name); case SLF4J_LAL: return Slf4jAdapter.createLocationAwareLog(name); case SLF4J: return Slf4jAdapter.createLog(name); default: return JavaUtilAdapter.createLog(name); &#125; &#125;// 类初始化时即读取用户指定的依赖，判断最终用哪种日志框架打印spring日志static &#123; if (isPresent(LOG4J_SPI)) &#123; // 若只依赖了slf4j还不够，还要指定使用org.apache.logging.slf4j.SLF4JProvider // 此类只存在于log4j-to-slf4j桥接器中 // 若spring或其它第三方jar包默认指定log4j2，则会去使用log4j // 要彻底只想用slf4j的话，在项目中加入log4j-to-slf4j，则此处判定通过 if (isPresent(LOG4J_SLF4J_PROVIDER) &amp;&amp; isPresent(SLF4J_SPI)) &#123; logApi = LogApi.SLF4J_LAL; &#125; else &#123; logApi = LogApi.LOG4J; &#125; &#125; else if (isPresent(SLF4J_SPI)) &#123; logApi = LogApi.SLF4J_LAL; &#125; else if (isPresent(SLF4J_API)) &#123; logApi = LogApi.SLF4J; &#125; else &#123; // jcl作为最后默认的日志体系 logApi = LogApi.JUL; &#125;&#125; spring-boot日志springBoot中将日志进行了统一，对于spring的默认log4j2也好，对于tomcat的jcl也好，最终都用slf4j下的logback去实现统一的打印，其原理就类似上面解决用slf4j统一打印spring的日志。 ch.qos.logback:logback-classic:1.2.3 其作用就是选定slf4j、引入logback、并绑定二者，因此在springboot中可以去使用logback日志 org.apache.logging.log4j:log4j-to-slf4j:2.13.3 其作用就是将spring及其他第三方jar包中依赖的log4j2给桥接转换为slf4j org.slf4j:jul-to-slf4j:1.7.30 在tomcat中，其日志用jcl实现的，此桥接器可以统一此类第三方jar包的日志","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://devloperhu.gitee.io/tags/Spring/"}]},{"title":"设计模式之备忘录模式","slug":"设计模式之备忘录模式","date":"2021-04-12T14:05:41.000Z","updated":"2021-12-16T15:12:19.257Z","comments":true,"path":"posts/15653.html","link":"","permalink":"https://devloperhu.gitee.io/posts/15653.html","excerpt":"","text":"备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 代码演示public static void main(String[] args) &#123; Originator originator = new Originator(); // 准备好了中间数据 originator.prepare(); // 将中间数据保存到备忘录中去 Memento memento = originator.createMemento(); // 将备忘录保存到备忘录管理器中去 Caretaker caretaker = new Caretaker(); caretaker.saveMemento(memento); // 基于中间数据执行了A方法，但是此时中间数据已经改变了 originator.executeA(); // 从备忘录管理器中获取备忘录 memento = caretaker.retrieveMemento(); // 将备忘录中保存好的中间数据重新设置到原发器中去，就将中间数据恢复成了之前备忘的状态 originator.setMemento(memento); // 接着再次执行方法B originator.executeB(); // 面临的场景 // 你的系统会生产出来一份中间数据，这份中间数据要么是没法一直在内存里保留，要么是可能会被修改 // 所以逼得你迫不得已，必须得通过备忘录的方式，将中间数据暂存一份儿 // 在一堆操作过后，可能之前内存中的中间数据都弄丢了，也可能中间数据被人篡改了 // 接下来，你需要从备忘录中恢复我们的中间数据 // 基于恢复后的中间数据，再次执行后面的操作 &#125; public interface Memento &#123; &#125; public static class Originator &#123; private String state; public void prepare() &#123; this.state = &quot;中间数据&quot;; &#125; public void executeA() &#123; System.out.println(&quot;基于中间数据【&quot; + state +&quot;】执行了A方法的逻辑&quot;); // 将state所代表的中间数据做出了修改 state += &quot;，A方法的结果数据&quot;; &#125; public void executeB() &#123; System.out.println(&quot;基于中间数据【&quot; + state +&quot;】执行了B方法的逻辑&quot;); state += &quot;，B方法的结果数据&quot;; &#125; public Memento createMemento() &#123; return new MementoImpl(state); &#125; public void setMemento(Memento memento) &#123; MementoImpl mementoImpl = (MementoImpl)memento; this.state = mementoImpl.getState(); &#125; private static class MementoImpl implements Memento &#123; private String state; public MementoImpl(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; &#125; &#125; public static class Caretaker &#123; private Memento memento; public void saveMemento(Memento memento) &#123; this.memento = memento; &#125; public Memento retrieveMemento() &#123; return this.memento; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之访问者模式","slug":"设计模式之访问者模式","date":"2021-04-11T11:58:21.000Z","updated":"2021-12-16T15:12:19.264Z","comments":true,"path":"posts/1606.html","link":"","permalink":"https://devloperhu.gitee.io/posts/1606.html","excerpt":"","text":"访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 代码演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public static void main(String[] args) &#123; Department leafDept1 = new Department(&quot;叶子部门1&quot;); Department leafDept2 = new Department(&quot;叶子部门2&quot;); Department leafDept3 = new Department(&quot;叶子部门3&quot;); Department subDept1 = new Department(&quot;子部门1&quot;); subDept1.getChildren().add(leafDept1); subDept1.getChildren().add(leafDept2); Department subDept2 = new Department(&quot;子部门2&quot;); subDept2.getChildren().add(leafDept3); Department parentDept = new Department(&quot;父部门&quot;); parentDept.getChildren().add(subDept1); parentDept.getChildren().add(subDept2); Visitor removeVisitor = new RemoveVisitor(); parentDept.accept(removeVisitor); Visitor updateStatusVisitor = new UpdateStatusVisitor(&quot;禁用&quot;); parentDept.accept(updateStatusVisitor); // 访问者模式，一般来说，就是跟组合模式结合起来使用的 // 组合模式代表了一种复杂的对象的类型 // 如果你后面要给树形的数据结构增加个什么功能，修改代码可能会比较麻烦 // 但是如果采用访问者模式来做，你可以在任何时候给树形的数据结构增加任何的功能&#125;public static class Department &#123; private String name; private List&lt;Department&gt; children = new ArrayList&lt;Department&gt;(); public Department(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Department&gt; getChildren() &#123; return children; &#125; public void setChildren(List&lt;Department&gt; children) &#123; this.children = children; &#125; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; &#125;public interface Visitor &#123; void visit(Department dept); &#125;public static class RemoveVisitor implements Visitor &#123; public void visit(Department dept) &#123; if(dept.getChildren().size() &gt; 0) &#123; for(Department child : dept.getChildren()) &#123; child.accept(this); &#125; &#125; System.out.println(&quot;删除部门【&quot; + dept.getName() + &quot;】&quot;); &#125; &#125; public static class UpdateStatusVisitor implements Visitor &#123; private String status; public void visit(Department dept) &#123; if(dept.getChildren().size() &gt; 0) &#123; for(Department child : dept.getChildren()) &#123; child.accept(this); &#125; &#125; System.out.println(&quot;将部门【&quot; + dept.getName() + &quot;】的状态修改为：&quot; + status); &#125; public UpdateStatusVisitor(String status) &#123; this.status = status; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之桥接模式","slug":"设计模式之桥接模式","date":"2021-04-10T12:24:03.000Z","updated":"2021-12-16T15:12:19.259Z","comments":true,"path":"posts/60984.html","link":"","permalink":"https://devloperhu.gitee.io/posts/60984.html","excerpt":"","text":"桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void main(String[] args) &#123; Implementor implementor = new ConcreteImplementor(); Abstraction abstraction = new RefinedAbstraction(implementor); abstraction.execute(); // implementor可以认为是一个代码组件，包含了一个接口和一个实现类 // abstraction可以认为是一个代码组件，包含了一个抽象类和一个子类 // abstraction要调用implementor的接口 // 在abstraction中包含了一个implementor的接口 // 在abstraction调用implementor的时候，实际上是面向implementor接口去编程和调用的 // 只不过我们会将implementor的实现类实例传入abstraction中 // abstraction调用implementor就是基于一个桥去调用的 // 不是说abstraction直接仅仅面向implementor实现类去编程的，面向implementor接口去编程的 // 所以abstraction和implementor两个代码组件之间的桥，就是implementor接口 // 这个一个代码组件面向另外一个代码组件的接口来编程，就是将那个接口作为一个桥 // 使用了桥接的设计模式来编程 // 桥接模式，都不需要运用，java之中，无处不桥接 // 几乎所有的编程，都是面向接口去编程的&#125;public interface Implementor &#123; void execute(); &#125;public static class ConcreteImplementor implements Implementor &#123; public void execute() &#123; System.out.println(&quot;执行了功能逻辑&quot;); &#125; &#125;public static abstract class Abstraction &#123; protected Implementor implementor; public Abstraction(Implementor implementor) &#123; this.implementor = implementor; &#125; public abstract void execute(); &#125;public static class RefinedAbstraction extends Abstraction &#123; public RefinedAbstraction(Implementor implementor) &#123; super(implementor); &#125; @Override public void execute() &#123; implementor.execute(); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之责任链模式","slug":"设计模式之责任链模式","date":"2021-04-09T12:13:09.000Z","updated":"2021-12-16T15:12:19.267Z","comments":true,"path":"posts/3292.html","link":"","permalink":"https://devloperhu.gitee.io/posts/3292.html","excerpt":"","text":"责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public static void main(String[] args) &#123; // 业务流程1 Handler thirdHandler = new Handler3(null); Handler secondHandler = new Handler2(thirdHandler); Handler firstHandler = new Handler1(secondHandler); firstHandler.execute(); // 业务流程2 thirdHandler = new Handler3(null); secondHandler = new Handler1(thirdHandler); firstHandler = new Handler2(secondHandler); firstHandler.execute(); // 责任链的思想 // 1：将一个业务流程中的多个步骤拆分开来，每个步骤封装到一个handler处理器中去 // 2：支持业务流程基于handler动态组装，不同的业务流程 -&gt; handler代表的代码组件可以复用 // 好处1：将这个代码封装到一个handler中，后面如果要对某个步骤的代码逻辑调整，修改一个handler即可 // 好处2：如果业务流程要修改，那么不需要拷贝大量的代码，只要基于handler动态组装业务流程即可 // 面向的场景 // 就是有多个业务流程，这些业务流程之间有相同的代码逻辑和步骤 // 可以用责任链模式来实现&#125;public static abstract class Handler &#123; protected Handler successor; public Handler(Handler successor) &#123; this.successor = successor; &#125; public abstract void execute(); &#125;public static class Handler1 extends Handler &#123; public Handler1(Handler successor) &#123; super(successor); &#125; public void execute() &#123; System.out.println(&quot;执行功能1&quot;); if(successor != null) &#123; successor.execute(); &#125; &#125; &#125;public static class Handler2 extends Handler &#123; public Handler2(Handler successor) &#123; super(successor); &#125; public void execute() &#123; System.out.println(&quot;执行功能2&quot;); if(successor != null) &#123; successor.execute(); &#125; &#125; &#125;public static class Handler3 extends Handler &#123; public Handler3(Handler successor) &#123; super(successor); &#125; public void execute() &#123; System.out.println(&quot;执行功能3&quot;); if(successor != null) &#123; successor.execute(); &#125; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之享元模式","slug":"设计模式之享元模式","date":"2021-04-08T11:45:39.000Z","updated":"2022-03-06T08:16:48.038Z","comments":true,"path":"posts/47555.html","link":"","permalink":"https://devloperhu.gitee.io/posts/47555.html","excerpt":"","text":"享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 享元模式的常见使用场景，其实就是jvm内缓存实现，如果我们不想引入ehcache之类缓存框架，就想简单一点，通过自己实现的一个map来缓存对应的一些数据，比如说每个权限的数据，或者每个员工的数据，在内存里自己维护一个缓存工厂，就是基于享元模式的思想来实现的。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void main(String[] args) &#123; Flyweight flyweight1 = FlyweightFactory.get(&quot;对象1&quot;); flyweight1.execute(); Flyweight flyweight2 = FlyweightFactory.get(&quot;对象1&quot;); flyweight2.execute(); System.out.println(flyweight1 == flyweight2); // 享元 // 享受，元数据 // 同一个数据，我就认为是一个元数据，整个系统里这个数据就一份，缓存起来 // 整个系统对这个数据，全部享受他一个对象实例即可 // 直接既有内存来缓存一块数据，用享元模式&#125;public static interface Flyweight &#123; void execute(); String getName(); void setName(String name); &#125;public static class ConcreteFlyweight implements Flyweight &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ConcreteFlyweight(String name) &#123; super(); this.name = name; &#125; public void execute() &#123; System.out.println(name + &quot;执行功能逻辑&quot;); &#125; &#125;public static class FlyweightFactory &#123; private static Map&lt;String, Flyweight&gt; cachePool = new HashMap&lt;String, Flyweight&gt;(); public static Flyweight get(String name) &#123; Flyweight flyweight = cachePool.get(name); if(flyweight == null) &#123; flyweight = new ConcreteFlyweight(name); cachePool.put(name, flyweight); &#125; return flyweight; &#125; &#125; 代码实战1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * BeanCopier工具类 * @author zhonghuashishan * */public class BeanCopierUtils &#123; /** * BeanCopier缓存 */ public static Map&lt;String, BeanCopier&gt; beanCopierCacheMap = new HashMap&lt;String, BeanCopier&gt;(); /** * 将source对象的属性拷贝到target对象中去 * @param source source对象 * @param target target对象 */ public static void copyProperties(Object source, Object target)&#123; String cacheKey = source.getClass().toString() + target.getClass().toString(); BeanCopier beanCopier = null; // 线程1和线程2，同时过来了 if (!beanCopierCacheMap.containsKey(cacheKey)) &#123; // 两个线程都卡这儿了 // 但是此时线程1先获取到了锁，线程2就等着 synchronized(BeanCopierUtils.class) &#123; // 线程1进来之后，发现这里还是没有那个BeanCopier实例 // 此时线程2，会发现缓存map中已经有了那个BeanCopier实例了，此时就不会进入if判断内的代码 if(!beanCopierCacheMap.containsKey(cacheKey)) &#123; // 进入到这里会创建一个BeanCopier实例并且放在缓存map中 beanCopier = BeanCopier.create(source.getClass(), target.getClass(), false); beanCopierCacheMap.put(cacheKey, beanCopier); &#125; else &#123; beanCopier = beanCopierCacheMap.get(cacheKey); &#125; &#125; &#125; else &#123; beanCopier = beanCopierCacheMap.get(cacheKey); &#125; beanCopier.copy(source, target, null); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之状态模式","slug":"设计模式之状态模式","date":"2021-04-07T14:03:22.000Z","updated":"2021-12-16T15:12:19.262Z","comments":true,"path":"posts/56671.html","link":"","permalink":"https://devloperhu.gitee.io/posts/56671.html","excerpt":"","text":"状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 代码演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static void main(String[] args) &#123; Context context = new Context(new NewState()); context.execute(1); context.execute(2); context.execute(3); // 适合场景，数据有状态，状态就一定会流转，从状态1变成状态2 // 将不同的状态要执行的代码逻辑封装在不同的state类中 // 有一个context类，负责根据传入的参数，决定这份数据的状态流转到什么状态 // 同时负责执行那个新状态的代码逻辑&#125;public interface State &#123; void execute(); &#125;public static class NewState implements State &#123; public void execute() &#123; System.out.println(&quot;执行销售出库单新建状态的逻辑&quot;); &#125; &#125;public static class ApprovingState implements State &#123; public void execute() &#123; System.out.println(&quot;执行销售出库单待审批状态的逻辑&quot;); &#125; &#125;public static class ApprovedState implements State &#123; public void execute() &#123; System.out.println(&quot;执行销售出库单已审批状态的逻辑&quot;); &#125; &#125;public static class FinishedState implements State &#123; public void execute() &#123; System.out.println(&quot;执行销售出库单已完成状态的逻辑&quot;); &#125; &#125;public static class Context &#123; private State state; public Context(State state) &#123; this.state = state; this.state.execute(); &#125; public void execute(int stateType) &#123; if(stateType == 1) &#123; this.state = new ApprovingState(); this.state.execute(); &#125; else if(stateType == 2) &#123; this.state = new ApprovedState(); this.state.execute(); &#125; else if(stateType == 3) &#123; this.state = new FinishedState(); this.state.execute(); &#125; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之策略模式","slug":"设计模式之策略模式","date":"2021-04-06T13:17:48.000Z","updated":"2021-12-15T15:40:44.186Z","comments":true,"path":"posts/41543.html","link":"","permalink":"https://devloperhu.gitee.io/posts/41543.html","excerpt":"","text":"策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 策略模式，将会成为最最高频使用的一种设计模式，他的常见应用场景，就是替换掉那一大坨复杂难懂的if else if else。对于那种过于复杂的选择判断逻辑，完全可以将选择哪种策略的过程放到工厂里去。工厂，可以是简单工厂，也可以是工厂方法，也可以是抽象工厂。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public static void main(String[] args) &#123; int discountStyle = 1; DiscountCalculateStrategy strategy = DiscountCalculateStrategryFactory .getDiscountCalculateStrategy(discountStyle); Context context = new Context(); context.setStrategy(strategy); context.calculate(); // 要点1：必须将if else的代码，封装到不同的策略类中 // 要点2：将选择哪种策略的逻辑给放到一个工厂类中去，选择策略的代码务必很简洁 // 要点3：context可有可无，具体是看你的策略执行这块如果就一行代码调用，不需要context // 如果context中的策略执行逻辑较为复杂一点，context来封装策略类的执行逻辑&#125;public interface DiscountCalculateStrategy &#123; void calculate(); &#125;public static class DiscountCalculateStrategyA implements DiscountCalculateStrategy &#123; public void calculate() &#123; System.out.println(&quot;执行优惠计价方式1的复杂业务逻辑&quot;); &#125; &#125;public static class DiscountCalculateStrategyB implements DiscountCalculateStrategy &#123; public void calculate() &#123; System.out.println(&quot;执行优惠计价方式2的复杂业务逻辑&quot;); &#125; &#125;public static class DiscountCalculateStrategyC implements DiscountCalculateStrategy &#123; public void calculate() &#123; System.out.println(&quot;执行优惠计价方式3的复杂业务逻辑&quot;); &#125; &#125;public static class DiscountCalculateStrategyDefault implements DiscountCalculateStrategy &#123; public void calculate() &#123; System.out.println(&quot;执行默认的优惠计价方式的复杂业务逻辑&quot;); &#125; &#125;public static class DiscountCalculateStrategryFactory &#123; public static DiscountCalculateStrategy getDiscountCalculateStrategy(int discountStyle) &#123; if(discountStyle == 1) &#123; return new DiscountCalculateStrategyA(); &#125; else if(discountStyle == 2) &#123; return new DiscountCalculateStrategyB(); &#125; else if(discountStyle == 3) &#123; return new DiscountCalculateStrategyC(); &#125; else &#123; return new DiscountCalculateStrategyDefault(); &#125; &#125; &#125;public static class Context &#123; private DiscountCalculateStrategy strategy; public DiscountCalculateStrategy getStrategy() &#123; return strategy; &#125; public void setStrategy(DiscountCalculateStrategy strategy) &#123; this.strategy = strategy; &#125; public void calculate() &#123; strategy.calculate(); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之组合模式","slug":"设计模式之组合模式","date":"2021-04-05T12:33:29.000Z","updated":"2021-12-15T15:16:49.039Z","comments":true,"path":"posts/59529.html","link":"","permalink":"https://devloperhu.gitee.io/posts/59529.html","excerpt":"","text":"组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public static void main(String[] args) &#123; Department leafDept1 = new Department(&quot;叶子部门1&quot;); Department leafDept2 = new Department(&quot;叶子部门2&quot;); Department leafDept3 = new Department(&quot;叶子部门3&quot;); Department subDept1 = new Department(&quot;子部门1&quot;); subDept1.getChildren().add(leafDept1); subDept1.getChildren().add(leafDept2); Department subDept2 = new Department(&quot;子部门2&quot;); subDept2.getChildren().add(leafDept3); Department parentDept = new Department(&quot;父部门&quot;); parentDept.getChildren().add(subDept1); parentDept.getChildren().add(subDept2); // 问题：对层级数据的操作，很恶心，很不方便，需要手工编写大量的代码 // for(Department subDept : parentDept.getChildren()) &#123; // if(subDept.getChildren().size() &gt; 0) &#123; // for(Department leafDept : subDept.getChildren()) &#123; // leafDept.remove(); // &#125; // &#125; // subDept.remove(); // &#125; // parentDept.remove(); // 对调用者来说，一步解决 parentDept.remove(); &#125;public static class Department &#123; private String name; private List&lt;Department&gt; children = new ArrayList&lt;Department&gt;(); public Department(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Department&gt; getChildren() &#123; return children; &#125; public void setChildren(List&lt;Department&gt; children) &#123; this.children = children; &#125; // public void remove() &#123; // System.out.println(&quot;删除部门【&quot; + name + &quot;】&quot;); // &#125; // 利用组合模式，自己完成对应的操作 public void remove() &#123; if(children.size() &gt; 0) &#123; for(Department child : children) &#123; child.remove(); &#125; &#125; System.out.println(&quot;删除部门【&quot; + name + &quot;】&quot;); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之命令模式","slug":"设计模式之命令模式","date":"2021-04-04T15:15:56.000Z","updated":"2021-12-15T15:17:46.953Z","comments":true,"path":"posts/7817.html","link":"","permalink":"https://devloperhu.gitee.io/posts/7817.html","excerpt":"","text":"命令模式命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static void main(String[] args) &#123; Command commandA = new CommandA(); Command commandB = new CommandB(); Invoker invoker = new Invoker(); invoker.setCommand(commandA); invoker.execute(); invoker.setCommand(commandB); invoker.execute(); // 举个例子 // 有两种请求要发送过来执行 // 一种请求是读请求，一种请求是写请求，不同请求要执行的功能逻辑是不一样的 // 此时就非常适合用这个命令模式 // 将读请求的功能逻辑封装到ReadCommand里面去，将写请求的功能逻辑封装到WriteCommand里面去 // 然后设置一个通用的一个命令执行的类 // 读请求来了，就封装ReadCommand，交给同一个命令执行类来执行即可 // 写请求来了，就封装WriteCommand，交给同一个命令感知性类来执行即可&#125;public interface Command &#123; void execute(); &#125;public static class CommandA implements Command &#123; public void execute() &#123; System.out.println(&quot;命令A的功能逻辑&quot;); &#125; &#125;public static class CommandB implements Command &#123; public void execute() &#123; System.out.println(&quot;命令B的功能逻辑&quot;); &#125; &#125;public static class Invoker &#123; private Command command; public Command getCommand() &#123; return command; &#125; public void setCommand(Command command) &#123; this.command = command; &#125; public void execute() &#123; System.out.println(&quot;一些别的逻辑A&quot;); command.execute(); System.out.println(&quot;一些别的逻辑B&quot;); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之代理模式","slug":"设计模式之代理模式","date":"2021-04-03T14:45:56.000Z","updated":"2021-12-13T14:26:28.321Z","comments":true,"path":"posts/64715.html","link":"","permalink":"https://devloperhu.gitee.io/posts/64715.html","excerpt":"","text":"代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123; AppData data = new ProxyRedisData(&quot;student&quot;); // 第一次数据将从MySQL加载 data.getData(); System.out.println(&quot;=====================&quot;); // 第二次则走Redis缓存 data.getData();&#125;public interface AppData &#123; void getData();&#125;public static class MysqlData implements AppData &#123; private String dataTable; public MysqlData(String dataTable) &#123; this.dataTable = dataTable; loadFromMysql(dataTable); &#125; @Override public void getData() &#123; System.out.println(&quot;show cache data &quot; + dataTable); &#125; private void loadFromMysql(String dataTable) &#123; System.out.println(&quot;Loading data from MySQL：&quot; + dataTable); &#125;&#125;public static class ProxyRedisData implements AppData &#123; private MysqlData cacheData; private String table; public ProxyRedisData(String table) &#123; this.table = table; &#125; @Override public void getData() &#123; if (cacheData == null) &#123; System.out.println(&quot;redis无此缓存数据，请先查MySQL&quot;); cacheData = new MysqlData(table); &#125; cacheData.getData(); &#125;&#125; 执行结果 12345redis无此缓存数据，请先查MySQLLoading data from MySQL：studentshow cache data student&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;show cache data student","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之观察者模式","slug":"设计模式之观察者模式","date":"2021-04-03T11:55:23.000Z","updated":"2021-12-15T15:32:10.155Z","comments":true,"path":"posts/63625.html","link":"","permalink":"https://devloperhu.gitee.io/posts/63625.html","excerpt":"","text":"观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。 场景 比如我们有一个目标对象，一旦这个目标对象的状态改变了，然后的话就去通知相关的对象，我的状态改变了，数据也变化了 前端开发，js脚本，要对界面上的各种视图组件，表格点击事件，按钮点击，添加监听器，一旦某种事件发生，就会执行监听器中的方法 系统A发送了一条消息到内存队列，系统B获取了消息开始执行操作，但是系统A需要知道系统B的一个执行的结果如何，此时怎么办？系统A需要注册一个观察者到系统B上去，系统B执行完了之后，将执行的结果，反过来通知给系统，我们就可以基于观察者模式去做 代码演示123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; Subject subject = new Subject(0); Observer observer = new ConcreteObserver(); subject.addObserver(observer); subject.setState(1); subject.setState(2); &#125;public static class Subject extends Observable &#123; private Integer state; public Subject(Integer state) &#123; this.state = state; &#125; public Integer getState() &#123; return state; &#125; public void setState(Integer state) &#123; // 在这里状态就改变了 this.state = state; // 通知关联的一些观察者，说我的状态变化了 this.setChanged(); // this.notifyObservers(state); // 推模式：告知并告知结果 this.notifyObservers(); // 拉模式：告知但结果自取 &#125;&#125;public static class ConcreteObserver implements Observer &#123; public void update(Observable o, Object arg) &#123; // Integer state = (Integer) arg; Subject subject = (Subject) o; Integer state = subject.getState(); System.out.println(&quot;目标对象的状态变化成：&quot; + state); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之中介者模式","slug":"设计模式之中介者模式","date":"2021-04-02T12:13:44.000Z","updated":"2021-12-13T14:26:28.310Z","comments":true,"path":"posts/15884.html","link":"","permalink":"https://devloperhu.gitee.io/posts/15884.html","excerpt":"","text":"中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 这个模式，担心的就是系统中各个子系统之前互相之间调用，乱成一团。所以就将系统之间互相调用的逻辑给放到一个所谓的中介者里面去。每个系统如果要通知别的系统干个什么事儿，直接就是调用中介者，中介者负责去调用别的系统。 在实际的企业开发中，不是这么玩儿的，很少有见到说封装一个所谓的中介者，去让各个模块之间解耦，思考这个模式的本质，让各个模块之间解耦合 最最常见的一个方式，就是系统与系统之间，不是走直接的接口调用，而是基于MQ来解耦。如果模块A要调用模块B和模块C，模块A发送一条消息到MQ里面去，模块B和模块C去消费这条消息，读到消息之后，知道模块A要调用自己，所以就执行对应的逻辑即可。常见于系统与系统之间的调用，可以基于MQ消息，异步执行的方式来调用，不需要同步调用和执行。 代码演示没有中介者的时候 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void main(String[] args) &#123; ModuleA moduleA = new ModuleA(); ModuleB moduleB = new ModuleB(); ModuleC moduleC = new ModuleC(); moduleA.execute(); moduleB.execute(); moduleC.execute(); // 模块之间有非常复杂的互相之间的跟蜘蛛网一样的调用 // 问题，每个模块都要去care很多其他的模块，互相之间耦合很严重 // 后面在修改代码的时候，代码不好改，模块B一旦修改了自己的代码，可能会影响模块A和模块C&#125;public static class ModuleA &#123; public void execute() &#123; ModuleB moduleB = new ModuleB(); ModuleC moduleC = new ModuleC(); moduleB.execute(&quot;模块A&quot;); moduleC.execute(&quot;模块A&quot;); &#125; public void execute(String invoker) &#123; System.out.println(invoker + &quot;在调用模块A的功能&quot;); &#125; &#125;public static class ModuleB &#123; public void execute() &#123; ModuleA moduleA = new ModuleA(); ModuleC moduleC = new ModuleC(); moduleA.execute(&quot;模块B&quot;); moduleC.execute(&quot;模块B&quot;); &#125; public void execute(String invoker) &#123; System.out.println(invoker + &quot;在调用模块B的功能&quot;); &#125; &#125;public static class ModuleC &#123; public void execute() &#123; ModuleA moduleA = new ModuleA(); ModuleB moduleB = new ModuleB(); moduleA.execute(&quot;模块C&quot;); moduleB.execute(&quot;模块C&quot;); &#125; public void execute(String invoker) &#123; System.out.println(invoker + &quot;在调用模块C的功能&quot;); &#125; &#125; 加入中介者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public static void main(String[] args) &#123; Mediator mediator = new Mediator(); ModuleA moduleA = new ModuleA(mediator); ModuleB moduleB = new ModuleB(mediator); ModuleC moduleC = new ModuleC(mediator); moduleA.execute(); moduleB.execute(); moduleC.execute(); // 好处在哪儿 // moduleA，只要知道一个中介者就可以了，具体跟其他模块的交互都封装在中介者里面了 // moduleB，同上 // moduleC，同上 // moduleA、B、C之间不再有任何的耦合，不再有复杂的交互关系，互相之间修改不会对对方产生什么影响&#125;public static class Mediator &#123; private ModuleA moduleA; private ModuleB moduleB; private ModuleC moduleC; public ModuleA getModuleA() &#123; return moduleA; &#125; public void setModuleA(ModuleA moduleA) &#123; this.moduleA = moduleA; &#125; public ModuleB getModuleB() &#123; return moduleB; &#125; public void setModuleB(ModuleB moduleB) &#123; this.moduleB = moduleB; &#125; public ModuleC getModuleC() &#123; return moduleC; &#125; public void setModuleC(ModuleC moduleC) &#123; this.moduleC = moduleC; &#125; public void moduleAInvoke() &#123; moduleB.execute(&quot;模块A通知中介者&quot;); moduleC.execute(&quot;模块A通知中介者&quot;); &#125; public void moduleBInvoke() &#123; moduleA.execute(&quot;模块B通知中介者&quot;); moduleC.execute(&quot;模块B通知中介者&quot;); &#125; public void moduleCInvoke() &#123; moduleA.execute(&quot;模块C通知中介者&quot;); moduleB.execute(&quot;模块C通知中介者&quot;); &#125; &#125;public static class ModuleA &#123; private Mediator mediator; public ModuleA(Mediator mediator) &#123; this.mediator = mediator; this.mediator.setModuleA(this); &#125; public void execute() &#123; mediator.moduleAInvoke(); &#125; public void execute(String invoker) &#123; System.out.println(invoker + &quot;在调用模块A的功能&quot;); &#125; &#125;public static class ModuleB &#123; private Mediator mediator; public ModuleB(Mediator mediator) &#123; this.mediator = mediator; this.mediator.setModuleB(this); &#125; public void execute() &#123; mediator.moduleBInvoke(); &#125; public void execute(String invoker) &#123; System.out.println(invoker + &quot;在调用模块B的功能&quot;); &#125; &#125;public static class ModuleC &#123; private Mediator mediator; public ModuleC(Mediator mediator) &#123; this.mediator = mediator; this.mediator.setModuleC(this); &#125; public void execute() &#123; mediator.moduleCInvoke(); &#125; public void execute(String invoker) &#123; System.out.println(invoker + &quot;在调用模块C的功能&quot;); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之原型模式","slug":"设计模式之原型模式","date":"2021-03-30T13:12:22.000Z","updated":"2022-03-06T09:44:20.375Z","comments":true,"path":"posts/8028.html","link":"","permalink":"https://devloperhu.gitee.io/posts/8028.html","excerpt":"","text":"原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 关键代码： 实现克隆操作，在 JAVA 继承 Cloneable，重写 clone() 代码演示不用克隆的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) &#123; // 手头有这么一个对象，需要进行拷贝 Product product = new Product(&quot;测试产品&quot;, new Component(&quot;测试组件&quot;)); // 手动来拷贝 Product copyProduct = new Product(product.getName(), product.getComponent()); System.out.println(copyProduct); // 问题是什么？ // 代码的拷贝逻辑，是每个要拷贝的调用方自己来实现的 // 相同的拷贝逻辑会分散在很多不同的地方，如果拷贝逻辑改变了，多个调用的地方都要修改代码 // 可维护性、可扩展性，很差&#125;public static class Component &#123; private String name; public Component(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Component [name=&quot; + name + &quot;]&quot;; &#125; &#125;public static class Product &#123; private String name; private Component component; public Product(String name, Component component) &#123; super(); this.name = name; this.component = component; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Component getComponent() &#123; return component; &#125; public void setComponent(Component component) &#123; this.component = component; &#125; @Override public String toString() &#123; return &quot;Product [name=&quot; + name + &quot;, component=&quot; + component + &quot;]&quot;; &#125; &#125; 使用克隆后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public static void main(String[] args) &#123; try &#123; Product product = new Product(&quot;测试产品&quot;, new Component(&quot;测试组件&quot;)); Product copyProduct = (Product) product.clone(); System.out.println(copyProduct); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 原型模式，就是在要拷贝的类里实现一个clone()方法，自己拷贝自己 // 拷贝的时候，就两个概念，浅拷贝，深拷贝 // 很多地方要克隆这个对象，不要自己维护克隆的逻辑，即使克隆逻辑修改了，只要在clone()方法里面修改&#125;public static class Component &#123; private String name; public Component(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Component [name=&quot; + name + &quot;]&quot;; &#125; // 深拷贝在其内部组件也需要逐级实现clone() @Override protected Object clone() throws CloneNotSupportedException &#123; return new Component(getName()); &#125; &#125;public static class Product &#123; private String name; private Component component; public Product(String name, Component component) &#123; super(); this.name = name; this.component = component; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Component getComponent() &#123; return component; &#125; public void setComponent(Component component) &#123; this.component = component; &#125; @Override public String toString() &#123; return &quot;Product [name=&quot; + name + &quot;, component=&quot; + component + &quot;]&quot;; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; // 浅拷贝，就是我们现在的一个实现 // 就是仅仅简单的对当前所有的变量进行一个拷贝 // return new Product(getName(), getComponent()); // 深拷贝，递归对自己引用的对象也进行拷贝 return new Product(getName(), (Component)getComponent().clone()); &#125; &#125; 代码实战1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 基础POJO类 * @author zhonghuashishan * */@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)public class AbstractObject &#123; /** * 浅度克隆 * @param clazz * @return * @throws Exception */ public &lt;T&gt; T clone(Class&lt;T&gt; clazz) throws Exception &#123; T target = clazz.newInstance(); return clone(target); &#125; /** * 浅度克隆 * @param clazz * @return * @throws Exception */ public &lt;T&gt; T clone(T target) throws Exception &#123; BeanCopierUtils.copyProperties(this, target); return target; &#125; /** * 深度克隆 * @param clazz * @param direction * @return * @throws Exception */ public &lt;T&gt; T clone(Class&lt;T&gt; clazz, Integer cloneDirection) throws Exception &#123; // 先完成基本字段的浅克隆 T target = clazz.newInstance(); BeanCopierUtils.copyProperties(this, target); // 完成所有List类型的深度克隆 // CategoryDTO Class&lt;?&gt; thisClazz = this.getClass(); Field[] fields = thisClazz.getDeclaredFields(); for(Field field : fields) &#123; field.setAccessible(true); // 如果判断某个字段是List类型的 // field = private List&lt;Relation&gt; relations; if(field.getType() != List.class) &#123; continue; &#125; // field.getType() List 不是 List&lt;Relation&gt; // List&lt;RelationDTO&gt;集合 List&lt;?&gt; list = (List&lt;?&gt;) field.get(this); if(list == null || list.size() == 0) &#123; continue; &#125; // 获取List集合中的泛型类型 // RelationDTO Class&lt;?&gt; listGenericClazz = getListGenericType(field); // 获取要克隆的目标类型 // 假设CloneDirection是反向，此时获取到的就是RelationVO Class&lt;?&gt; cloneTargetClazz = getCloneTargetClazz(listGenericClazz, cloneDirection); // 将list集合克隆到目标list集合中去 List clonedList = new ArrayList(); cloneList(list, clonedList, cloneTargetClazz, cloneDirection); // 获取设置克隆好的list的方法名称 // setRelations Method setFieldMethod = getSetCloneListFieldMethodName(field, clazz); setFieldMethod.invoke(target, clonedList); // target是CategoryVO对象，此时就是调用CategoryVO的setRelations方法， // 将克隆好的List&lt;CategoryVO&gt;给设置进去 &#125; return target; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之构造器模式","slug":"设计模式之构造器模式","date":"2021-03-29T12:44:31.000Z","updated":"2021-12-12T15:55:11.169Z","comments":true,"path":"posts/34453.html","link":"","permalink":"https://devloperhu.gitee.io/posts/34453.html","excerpt":"","text":"构造器模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 代码演示普通代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; // 构造这个复杂的product对象 Product product = new Product(); // 设置field1属性 System.out.println(&quot;在设置field1之前进行复杂的校验逻辑&quot;); product.setField1(&quot;值1&quot;); // 设置field2属性 System.out.println(&quot;在设置field2之前进行复杂的数据格式转化逻辑&quot;); product.setField2(&quot;值2&quot;); // 设置field3属性 System.out.println(&quot;在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联&quot;); product.setField3(&quot;值3&quot;); // 上面是简化的一个逻辑，实际上对于一些有几十个字段，甚至是上百个字段的复杂对象的构建 // 上面那段代码会极度膨胀，非常复杂 // 一个是说，大量代码堆积在一起，维护性非常差，可读性非常差，读不懂，没法改 // 另外一个，这段逻辑，如果在多个地方都有使用的话，一旦这段逻辑出现了一些变化，那么可能就需要 // 在多个地方修改 &#125; public static class Product &#123; private String field1; private String field2; private String field3; public String getField1() &#123; return field1; &#125; public void setField1(String field1) &#123; this.field1 = field1; &#125; public String getField2() &#123; return field2; &#125; public void setField2(String field2) &#123; this.field2 = field2; &#125; public String getField3() &#123; return field3; &#125; public void setField3(String field3) &#123; this.field3 = field3; &#125; &#125; 用构造器设计模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public static void main(String[] args) &#123; Director director = new Director(new ConcreteBuilder()); Product product = director.build(&quot;值1&quot;, &quot;值2&quot;, &quot;值3&quot;); System.out.println(product); // 好处1：通过builder接口将复杂构建步骤拆分成了多个部分，代码逻辑清晰，维护性和扩展性都很好// 好处2：将对象构建的过程，封装在了director里面，director来基于builder进行构建，构建逻辑修改，不需要修改很多地方// 好处3：相对于工厂，有一个很好的抽象设计，director和builder&#125; public static class Product &#123; private String field1; private String field2; private String field3; public String getField1() &#123; return field1; &#125; public void setField1(String field1) &#123; this.field1 = field1; &#125; public String getField2() &#123; return field2; &#125; public void setField2(String field2) &#123; this.field2 = field2; &#125; public String getField3() &#123; return field3; &#125; public void setField3(String field3) &#123; this.field3 = field3; &#125; @Override public String toString() &#123; return &quot;Product [field1=&quot; + field1 + &quot;, field2=&quot; + field2 + &quot;, field3=&quot; + field3 + &quot;]&quot;; &#125; &#125; public interface Builder &#123; void field1(String value); void field2(String value); void field3(String value); Product create(); &#125; public static class ConcreteBuilder implements Builder &#123; private Product product = new Product(); public void field1(String value) &#123; System.out.println(&quot;在设置field1之前进行复杂的校验逻辑&quot;); product.setField1(value); &#125; public void field2(String value) &#123; System.out.println(&quot;在设置field2之前进行复杂的数据格式转化逻辑&quot;); product.setField2(value); &#125; public void field3(String value) &#123; System.out.println(&quot;在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联&quot;); product.setField3(value); &#125; public Product create() &#123; return product; &#125; &#125; /** * director是面向builder的接口，来编程的 * director可以复杂控制构建的一个步骤，具体的每个步骤的逻辑封装在具体的builder类中 * 如果我们此时要更换一整套的构建逻辑，可以再搞一个新的builder类就可以了 * 但是我们的整个构建步骤是没有任何改变的 * * 如果整个构建步骤变化了，但是对构建的逻辑是没有影响的 * */ public static class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public Product build(String field1, String field2, String field3) &#123; builder.field1(field1); builder.field2(field2); builder.field3(field3); return builder.create(); &#125; &#125; 优化后的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public static void main(String[] args) &#123; // 将构造的过程掌握在调用者手中 Product product = new ConcreteBuilder() .field1(&quot;值1&quot;) .field2(&quot;值2&quot;) .field3(&quot;值3&quot;) .create(); System.out.println(product); // 现在基本上流行的一些开源框架，构造器模式的运用，一般都是上面这种变种模式&#125;public static class Product &#123; private String field1; private String field2; private String field3; public String getField1() &#123; return field1; &#125; public void setField1(String field1) &#123; this.field1 = field1; &#125; public String getField2() &#123; return field2; &#125; public void setField2(String field2) &#123; this.field2 = field2; &#125; public String getField3() &#123; return field3; &#125; public void setField3(String field3) &#123; this.field3 = field3; &#125; @Override public String toString() &#123; return &quot;Product [field1=&quot; + field1 + &quot;, field2=&quot; + field2 + &quot;, field3=&quot; + field3 + &quot;]&quot;; &#125; &#125;public interface Builder &#123; Builder field1(String value); Builder field2(String value); Builder field3(String value); Product create(); &#125;public static class ConcreteBuilder implements Builder &#123; private Product product = new Product(); public Builder field1(String value) &#123; System.out.println(&quot;在设置field1之前进行复杂的校验逻辑&quot;); product.setField1(value); return this; &#125; public Builder field2(String value) &#123; System.out.println(&quot;在设置field2之前进行复杂的数据格式转化逻辑&quot;); product.setField2(value); return this; &#125; public Builder field3(String value) &#123; System.out.println(&quot;在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联&quot;); product.setField3(value); return this; &#125; public Product create() &#123; return product; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之外观模式","slug":"设计模式之外观模式","date":"2021-03-28T14:28:53.000Z","updated":"2021-12-12T15:55:00.765Z","comments":true,"path":"posts/54086.html","link":"","permalink":"https://devloperhu.gitee.io/posts/54086.html","excerpt":"","text":"外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 比如说service就是一个经典的门面模式。如果一个子系统里有多个DAO组件，然后如果别的子系统要实现一段业务逻辑，需要使用这个子系统的多个DAO组件，那就会导致别的子系统代码会很乱，需要care这个子系统很多DAO组件的实现。但是这个组件可以基于多个DAO组件封装出来一个service接口，然后别的系统就针对一个service接口开发即可。这个service不就是一个典型的门面吗？ 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public interface ModuleA &#123; void operate(); &#125;public class ModuleAImpl implements ModuleA &#123; public void operate() &#123; System.out.println(&quot;实现模块A的功能&quot;); &#125; &#125;public interface ModuleB &#123; void operate(); &#125;public class ModuleBImpl implements ModuleB &#123; public void operate() &#123; System.out.println(&quot;实现模块B的功能&quot;); &#125; &#125;public interface ModuleC &#123; void operate(); &#125;public class ModuleCImpl implements ModuleC &#123; public void operate() &#123; System.out.println(&quot;实现模块C的功能&quot;); &#125; &#125;public class SystemAFacade &#123; public static void operate() &#123; ModuleA moduleA = new ModuleAImpl(); moduleA.operate(); ModuleB moduleB = new ModuleBImpl(); moduleB.operate(); ModuleC moduleC = new ModuleCImpl(); moduleC.operate(); &#125; &#125;public class SystemB &#123; public static void main(String[] args) &#123; SystemA.operate(); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之单例模式","slug":"设计模式之单例模式","date":"2021-03-27T13:35:22.000Z","updated":"2021-12-12T07:49:50.985Z","comments":true,"path":"posts/62332.html","link":"","permalink":"https://devloperhu.gitee.io/posts/62332.html","excerpt":"","text":"常见的场景（1）比如说，你自定义了一个框架，自定义了一份xml格式的一个配置文件，你要读取这个配置文件，这个配置文件中的数据，读取到类中，这个类的实例，只要保存一份就可以。那么此时可以使用单例模式，将这个类做成他的实例只能有一个，在这个实例中保存了配置文件中的数据 （2）类似于我们之前给大家讲解的那个工厂模式，有些工厂是需要实例化对象的，要基于实例化对象，来实现继承、接口、实现等功能，工厂实例可以做成单例的，就可以了 （3）你自己去判断，如果是一个类的实例只需要保持一份，那就做成单例 代码演示 饿汉模式 123456789101112public class Singleton &#123; private static final Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 即初始化的时候就给创建出来。 安全的饱汉模式 1234567891011121314151617public class Singleton &#123; // volatile防止指令重排 private volatile static Singleton instance; public static Singleton getInstance() &#123; // 双重检查锁（Double-Checked Lock） if(instance == null) &#123; synchronized(Sinngleton.class) &#123; if(instance == null) &#123; Singleton.instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; Initialization on Demand Holder 使用内部类来做到延迟加载对象，在初始化这个内部类的时候，JLS(Java Language Sepcification)会保证这个类的线程安全。这种写法最大的美在于，完全使用了Java虚拟机的机制进行同步保证，没有一个同步的关键字。 在JLS12.4中关于一个类或接口将被立即初始化的相关说明： 1A static field declared by T is used and the field is not a constant variable 如果使用一个类的非常量静态变量，会立即初始化该类。 注意final关键字修饰的变量，并不一定是constant variable。只有基本类型或者是String类型的变量，才可能成为constant variable。 1234567891011121314151617181920public class Singleton &#123; // Private constructor prevents instantiation from other classes private Singleton() &#123; &#125; //LazyHolder is loaded on the first execution of LazyHolder.getInstance() // or the first access to SingletonHolder.INSTANCE, not before. private static class LazyHolder &#123; // 此处不用public，是防止LazyHolder的private被修改为public // 此处若用private，作为内部类，编译器在内部类中插入packge private method // 使得外部类调用这些getter和setter方法的形式来访问内部类的private字段 // 使用默认的package private访问权限细节上更加的合理 static final Singleton singleton = new Singleton(); &#125; public static Singleton getInstance() &#123; return LazyHolder.singleton; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之简单工厂模式/工厂方法模式/抽象工厂模式","slug":"设计模式之简单工厂模式-工厂方法模式-抽象工厂模式","date":"2021-03-26T12:49:29.000Z","updated":"2021-12-06T15:29:22.017Z","comments":true,"path":"posts/35943.html","link":"","permalink":"https://devloperhu.gitee.io/posts/35943.html","excerpt":"","text":"工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 工厂方法模式（Factory Method Pattern）：模板方法模式+简单工厂模式，简单工厂模式稍微复杂一点的变种。 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 代码演示简单工厂模式：123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; // 对简单工厂，增加功能修改的是工厂类 Product product = ProductFactory.create(); product.excute();&#125;public static abstract class Product &#123; abstract void excute();&#125;public static class ProdectImpl extends Product &#123; @Override public void excute() &#123; System.out.println(&quot;产品1执行流程&quot;); &#125;&#125;public static class NewProdectImpl extends Product &#123; @Override public void excute() &#123; System.out.println(&quot;新产品执行流程&quot;); &#125;&#125;public static class ProductFactory &#123; public static Product create() &#123; // return new ProdectImpl(); return new NewProdectImpl(); &#125;&#125; 优点：通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了，而不必管这些对象究竟如何创建及如何组织的。 缺点：将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。 工厂方法模式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123; ProductFactory factory = new Factory1(); factory.get().excute(); // 对工厂方法，增加功能修改的是客户端 ProductFactory factory2 = new Factory2(); factory2.get().excute();&#125;public static abstract class Product &#123; abstract void excute();&#125;public static class ProdectImpl extends Product &#123; @Override public void excute() &#123; System.out.println(&quot;产品1执行流程&quot;); &#125;&#125;public static class NewProdectImpl extends Product &#123; @Override public void excute() &#123; System.out.println(&quot;新产品执行流程&quot;); &#125;&#125;public static abstract class ProductFactory &#123; public Product get() &#123; System.out.println(&quot;生产产品前通用执行流程,修改&quot;); return create(); &#125; // 生产产品方法 abstract Product create();&#125;public static class Factory1 extends ProductFactory &#123; public Product create() &#123; return new ProdectImpl(); &#125;&#125;public static class Factory2 extends ProductFactory &#123; public Product create() &#123; return new NewProdectImpl(); &#125;&#125; 优点：符合开闭原则，具有很强的的扩展性、弹性和可维护性。扩展时只要添加一个ConcreteCreator，而无须修改原有的ConcreteCreator，因此维护性也好。解决了简单工厂对修改开放的问题。 缺点：一个具体产品对应一个类，当具体产品过多时会使系统类的数目过多，增加系统复杂度。 抽象工厂模式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public static void main(String[] args) &#123; AbstractFactoryPartternDemo abstractFactoryPartternDemo = new AbstractFactoryPartternDemo(); AbstractFactory factory1 = abstractFactoryPartternDemo.new FactoryImpl1(); ProductA createProductA1 = factory1.createProductA(); ProductB createProductB1 = factory1.createProductB(); createProductA1.operate(); createProductB1.operate(); AbstractFactory factory2 = abstractFactoryPartternDemo.new FactoryImpl2(); ProductA createProductA2 = factory2.createProductA(); ProductB createProductB2 = factory2.createProductB(); createProductA2.operate(); createProductB2.operate();&#125;public interface ProductA &#123; void operate();&#125;public interface ProductB &#123; void operate();&#125;public class ProductAImpl1 implements ProductA &#123; public void operate() &#123; System.out.println(&quot;产品A的实现1的功能执行&quot;); &#125;&#125;public class ProductBImpl1 implements ProductB &#123; public void operate() &#123; System.out.println(&quot;产品B的实现1的功能执行&quot;); &#125;&#125;public class ProductAImpl2 implements ProductA &#123; public void operate() &#123; System.out.println(&quot;产品A的实现2的功能执行&quot;); &#125;&#125;public class ProductBImpl2 implements ProductB &#123; public void operate() &#123; System.out.println(&quot;产品B的实现2的功能执行&quot;); &#125;&#125;public interface AbstractFactory &#123; ProductA createProductA(); ProductB createProductB();&#125;public class FactoryImpl1 implements AbstractFactory &#123; public ProductA createProductA() &#123; return new ProductAImpl1(); &#125; public ProductB createProductB() &#123; return new ProductBImpl1(); &#125;&#125;public class FactoryImpl2 implements AbstractFactory &#123; public ProductA createProductA() &#123; return new ProductAImpl2(); &#125; public ProductB createProductB() &#123; return new ProductBImpl2(); &#125;&#125; 优点：一个具体的工厂实现代表的是一个产品族。 缺点：不太容易扩展新的产品，如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之模板方法模式","slug":"设计模式之模板方法模式","date":"2021-03-25T14:12:49.000Z","updated":"2021-12-05T15:42:41.623Z","comments":true,"path":"posts/8412.html","link":"","permalink":"https://devloperhu.gitee.io/posts/8412.html","excerpt":"","text":"模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。其主要优点如下。 封装不变部分，扩展可变部分。 提取公共代码，便于维护。 行为由父类控制，子类实现。 其主要缺点是：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。 代码演示未使用模板模式的代码 12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; CalculateDiscount1 calculateDiscount1 = new CalculateDiscount1(); calculateDiscount1.calculate(); CalculateDiscount2 calculateDiscount2 = new CalculateDiscount2(); calculateDiscount2.calculate(); CalculateDiscount3 calculateDiscount3 = new CalculateDiscount3(); calculateDiscount3.calculate();&#125;public static class CalculateDiscount1 &#123; public void calculate() &#123; System.out.println(&quot;通用的计算逻辑&quot;); System.out.println(&quot;折扣1的特殊计算逻辑&quot;); &#125;&#125;public static class CalculateDiscount2 &#123; public void calculate() &#123; System.out.println(&quot;通用的计算逻辑&quot;); System.out.println(&quot;折扣2的特殊计算逻辑&quot;); &#125;&#125;public static class CalculateDiscount3 &#123; public void calculate() &#123; System.out.println(&quot;通用的计算逻辑&quot;); System.out.println(&quot;折扣3的特殊计算逻辑&quot;); &#125;&#125; 使用模板模式后的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; CalculateDiscount1 calculateDiscount1 = new CalculateDiscount1(); calculateDiscount1.calculate(); CalculateDiscount2 calculateDiscount2 = new CalculateDiscount2(); calculateDiscount2.calculate(); CalculateDiscount3 calculateDiscount3 = new CalculateDiscount3(); calculateDiscount3.calculate();&#125;public static abstract class DiscountCalculate &#123; public final void calculate() &#123; // 模板方法 commonCalculate(); specificCalculate(); &#125; private void commonCalculate() &#123; System.out.println(&quot;通用计算逻辑，修改了&quot;); &#125; protected abstract void specificCalculate();&#125;public static class CalculateDiscount1 extends DiscountCalculate &#123; @Override protected void specificCalculate() &#123; System.out.println(&quot;折扣1的特殊计算逻辑&quot;); &#125;&#125;public static class CalculateDiscount2 extends DiscountCalculate &#123; @Override protected void specificCalculate() &#123; System.out.println(&quot;折扣2的特殊计算逻辑&quot;); &#125;&#125;public static class CalculateDiscount3 extends DiscountCalculate &#123; @Override protected void specificCalculate() &#123; System.out.println(&quot;折扣3的特殊计算逻辑&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之适配器模式","slug":"设计模式之适配器模式","date":"2021-03-24T12:56:39.000Z","updated":"2021-12-05T09:16:33.401Z","comments":true,"path":"posts/31793.html","link":"","permalink":"https://devloperhu.gitee.io/posts/31793.html","excerpt":"","text":"适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。其主要优点如下。 可以让任何两个没有关联的类一起运行。 提高了类的复用。 增加了类的透明度。 灵活性好。 其主要缺点是：过多地使用适配器，会让系统非常零乱，不易整体进行把握。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void main(String[] args) &#123; // 未使用适配器 OldInterfaceImpl oldInterfaceImpl = new OldInterfaceImpl(); NewInterfaceImpl newInterfaceImpl = new NewInterfaceImpl(); oldInterfaceImpl.oldExcute(); newInterfaceImpl.newExcute(); // 使用适配器 // 新老两接口，用适配器后，都可以用新接口进行开发 NewInterface oldObject = new Adapter(new OldInterfaceImpl()); NewInterface newObject = new NewInterfaceImpl(); oldObject.newExcute(); newObject.newExcute();&#125;public static class Adapter implements NewInterface &#123; private OldInterface oldInterface; public Adapter(OldInterface oldInterface) &#123; this.oldInterface = oldInterface; &#125; @Override public void newExcute() &#123; oldInterface.oldExcute(); &#125;&#125;public static interface OldInterface &#123; void oldExcute();&#125;public static class OldInterfaceImpl implements OldInterface &#123; @Override public void oldExcute() &#123; System.out.println(&quot;执行了老方法&quot;); &#125;&#125;public static interface NewInterface &#123; void newExcute();&#125;public static class NewInterfaceImpl implements NewInterface &#123; @Override public void newExcute() &#123; System.out.println(&quot;执行了新方法&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式之迭代器模式","slug":"设计模式之迭代器模式","date":"2021-03-23T13:33:36.000Z","updated":"2021-12-05T07:12:45.178Z","comments":true,"path":"posts/35042.html","link":"","permalink":"https://devloperhu.gitee.io/posts/35042.html","excerpt":"","text":"前情提要&emsp;&emsp;最近发现新公司项目的代码部分过于不规范，可能是项目排期紧，没时间做重构等优化。虽然当时能快速完成任务，且满足业务需求，但是对于后期维护或者新扩展功能时，因为原始代码过于混乱，会导致自己或后来的开发人员痛不欲生，因此准备温习下之前学习的设计模式，在后期自己写代码时，能更多的去运用设计模式，使自己的代码更加优雅。 迭代器模式提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。 访问一个聚合对象的内容而无须暴露它的内部表示。 遍历任务交由迭代器完成，这简化了聚合类。 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。 增加新的聚合类和迭代器类都很方便，无须修改原有代码。 封装性良好，为遍历不同的聚合结构提供一个统一的接口。 其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public static void main(String[] args) &#123; Student student1 = new Student(&quot;xiaoming&quot;); Student student2 = new Student(&quot;xiaowang&quot;); ClassRoom classRoom = new ClassRoom(3); classRoom.addStudent(student1); classRoom.addStudent(student2); System.out.println(classRoom.size()); System.out.println(classRoom.isEmpty()); Iterator&lt;Object&gt; iterator = classRoom.iterator(); while (iterator.hasNext()) &#123; Student student = (Student) iterator.next(); if (student == null) &#123; System.out.println(&quot;null&quot;); &#125; else &#123; System.out.println(student.toString()); &#125; &#125;&#125;public static class Student &#123; private String name; public Student() &#123; &#125; public Student(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;student [name=&quot; + name + &quot;]&quot;; &#125;&#125;/** * 聚合接口，声明使用了Iterator接口 */public interface Aggregate &#123; public abstract Iterator&lt;Object&gt; iterator(); public abstract int size(); public abstract boolean isEmpty();&#125;/** * 目标类的迭代器实现Iterator接口及其方法 */public static class ClassroomIterator implements Iterator&lt;Object&gt; &#123; private ClassRoom classroom; private int index; public ClassroomIterator(ClassRoom classroom) &#123; this.classroom = classroom; this.index = 0; &#125; public boolean hasNext() &#123; if (index &lt; classroom.size()) &#123; return true; &#125; else &#123; return false; &#125; &#125; public Object next() &#123; Student student = classroom.getStudent(index); index++; return student; &#125;&#125;/** * 目标类通过聚合类获取Iterator实例 */public static class ClassRoom implements Aggregate &#123; private Student[] students; private int size = 0; private int last = 0; public ClassRoom(int size) &#123; this.size = size; this.students = new Student[size]; &#125; public void addStudent(Student student) &#123; this.students[last] = student; last++; &#125; public Student getStudent(int index) &#123; return students[index]; &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return last == 0 ? true : false; &#125; @Override public Iterator&lt;Object&gt; iterator() &#123; return new ClassroomIterator(this); &#125;&#125; 若改变了子元素类型，通过继承聚合对象，依然可以沿用迭代器去进行遍历操作。 1234567891011121314School school = new School(2);school.addClassRoom(classRoom);school.addClassRoom(classRoom1);System.out.println(school.size());System.out.println(school.isEmpty());Iterator&lt;Object&gt; iterator1 = school.iterator();while (iterator1.hasNext()) &#123; ClassRoom classRoom2 = (ClassRoom) iterator1.next(); if (classRoom2 == null) &#123; System.out.println(&quot;null&quot;); &#125; else &#123; System.out.println(classRoom2.toString()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static class SchoolIterator implements Iterator&lt;Object&gt; &#123; private School school; private int index; public SchoolIterator(School school) &#123; this.school = school; this.index = 0; &#125; public boolean hasNext() &#123; if (index &lt; school.size()) &#123; return true; &#125; else &#123; return false; &#125; &#125; public Object next() &#123; ClassRoom student = school.getClassRoom(index); index++; return student; &#125; &#125; public static class School implements Aggregate &#123; private List&lt;ClassRoom&gt; calssRooms; private int size = 0; private int last = 0; public School(int size) &#123; this.size = size; this.calssRooms = new ArrayList&lt;&gt;(size); &#125; public void addClassRoom(ClassRoom calssRoom) &#123; calssRooms.add(last, calssRoom); last++; &#125; public ClassRoom getClassRoom(int index) &#123; return calssRooms.get(index); &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return last == 0 ? true : false; &#125; @Override public Iterator&lt;Object&gt; iterator() &#123; return new SchoolIterator(this); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Maven产生依赖冲突原因及解决方法","slug":"maven产生依赖冲突原因及解决方法","date":"2021-03-19T07:56:44.000Z","updated":"2021-09-20T15:50:09.405Z","comments":true,"path":"posts/39390.html","link":"","permalink":"https://devloperhu.gitee.io/posts/39390.html","excerpt":"","text":"简介在项目中，经常会遇见maven依赖冲突，如XXXclass not found、XXX() not found、MyClass.doMethod() not found等，但是一看pom.xml，明明有声明啊，那可能是某个二级依赖或者三级依赖的锅吧，然后一通百度，复制粘贴解决问题。但是究竟为啥呢？ 原因解析 首先看maven的传递性依赖我们项目中经常引入的jar包经常并非是单一 的，它可能也依赖其他的jar包，但是有了maven的传递依赖性，会自动递归解析所有的依赖，然后负责将依赖下载下来，接着所有层级的依赖都会成为我们项目的依赖，无需手动干预。比如junit依赖了A，A又依赖了B，在引入Junit的时候，会自动引入A和B的。但是依赖范围也会影响最终是否引入，这里就不做讨论。 依赖调解既然说maven会自动解析所有层级的依赖，给我们自动下载所有的依赖，但是可能会出现依赖版本的问题。比如A-&gt;B-&gt;C-&gt;X(1.0)，A-&gt;D-&gt;X(2.0)，A有两个传递性依赖X，不同的版本就产生了依赖冲突的问题，maven如何解决呢？ 此时就会依赖调解，就近原则，离A最近的选用，就是X的2.0版本。 如果A-&gt;B-&gt;X(1.0)和A-&gt;D-&gt;X(2.0)，路径等长呢？那么会选择第一声明原则，哪个依赖在pom.xml里先声明，就用哪个。 依赖冲突在上述依赖调解的过程，会出现一个问题，就是如果最终依赖了低版本的，刚好有其他地方用到的高版本才有这个类，或者这个方法，这是就会出现一开始说的那些异常。 123比如你依赖了A和B，此时A依赖了C-1.0，B依赖了D，D依赖了C-2.0X -&gt; A -&gt; C-1.0X -&gt; B -&gt; D -&gt; C-2.0 解决方法用mvn dependency:tree这个命令看一下整个项目的依赖路径树，看看所有的依赖路径里，有哪几个版本的C项目，看一下，自己看看要用哪个版本的C，然后将其他的C版本的依赖全部手动排除掉。 如上的话，定位原因，因为A-C1.0最短，所以用了C-1.0，也就是旧的版本。所以此时要做的事情就是，在A下面： 1234567891011&lt;dependency&gt; &lt;groupId&gt;A&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;C&lt;/groupId&gt; &lt;artifactId&gt;C&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"HashMap允许null而ConcurrentHashMap不允许?","slug":"HashMap允许null而ConcurrentHashMap不允许","date":"2021-03-18T15:05:00.000Z","updated":"2021-09-19T08:00:45.404Z","comments":true,"path":"posts/59999.html","link":"","permalink":"https://devloperhu.gitee.io/posts/59999.html","excerpt":"","text":"简介最近同事去面试，问了他为什么ConcurrentHashMap中的key和value为什么不能为null？ 源码解析首先看HashMap: 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 当key为 null 时，在计算 hashCode 时直接算作0，value为 null 也没做特殊说明，所以key和value均能为null。 再看ConcurrentHashMap: 1234final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); ...&#125; 一上来就讲key和value为null给否决了，就是这么直接，但是既然问了，总不能就说作者就是这样写的。。。 深入探索往上翻，看到作者是Doug Lea，Java届的巨佬，而且是JDK1.5的 ，这么久肯定也有人有疑问，就在 Google上找答案，最终找到Doug Lea和Joshua Bloch的亲自回答，原文链接如下： http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002485.html http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002486.html 大致意思就是，对于Map的value为null ，你是会有两种结果得到的： get(key)获取的就是null get(key)该key不存在，因此返回null 12345678/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key.*/public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 这就产生了二义性问题，HashMap线程不安全，一般在单线程下使用，可以用containsKey(key)进行判断该null的准确含义。而ConcurrentHashmap多在并发环境下使用，因此在你用containsKey(key)方法时，可能另一个线程B执行concurrentHashMap.put(key,null)操作，将本不存在的key插入map中，这样就与实际情况不符。也就是原文中“the map might have changed between calls”，因此回答了ConcurrentHashMap中value不为null的。 但是 key 不为null并没有解释，看了两位巨佬自己的回答 ，大概只能说作者Doug Lea不喜欢null，所以在设计之初就不允许了null的key存在。Doug还提出一点，可以定义一个名称为NULL的全局的Object。当需要用null值的时候，用这个NULL来代替，以假乱真。 123Would it be easier to declare somewhere static final Object NULL = new Object();and replace all use of nulls in uses of maps with NULL?","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"工作中的总结（一）","slug":"工作中的总结","date":"2021-03-17T14:56:46.000Z","updated":"2021-09-20T15:56:04.792Z","comments":true,"path":"posts/16217.html","link":"","permalink":"https://devloperhu.gitee.io/posts/16217.html","excerpt":"","text":"简介最近公司需要批处理生成带T-1日期的sql脚本文件，百度了几个靠谱的方案，修改了各种bug后，记录一下。 生成T-1日期创建时间为T-1的文件： 1234567891011121314151617181920212223242526272829303132333435363738394041@echo off&amp;setlocal enabledelayedexpansionset yyyy=%date:~0,4%:: 将月份两位当做十进制来处理，避免08和09被当做八进制处理报错（20210901突然爆出生产问题源于此，其实0801也出问题了）set mm1=%date:~5,1%set mm2=%date:~6,1%set mm=!mm1!*10+!mm2!set /a mm=!mm!+0:: 将日期两位当做十进制来处理，避免08和09被当做八进制处理报错set dd1=%date:~8,1%set dd2=%date:~9,1%set dd=!dd1!*10+!dd2!echo 今天是：%date:~0,4%%date:~5,2%%date:~8,2%set /a od=!dd!-1:: 对于1-9月份的非1号进行月份补0处理if !od! neq 0 if !mm! lss 10 set mm=0!mm!:: 处理每个月1号特殊情况if !od!==0 call :dd0:: 处理每年一月的特殊情况if !mm!==0 call :mm0:: 对于1-9号进行补0处理if !od! lss 10 set od=0!od!echo 昨天是: !yyyy!!mm!!od!pauseexit:dd0set /a mm=!mm!-1for %%a in (1 3 5 7 8 10 12)do set %%add=31set /a pddd=!yyyy!*10/4set pd2d=!pddd:~-1,1!set 2dd=28if !pd2d!==0 set 2dd=29for %%b in (4 6 9 11)do set %%bdd=30set od=!%mm%dd!:: 对于1-9月进行补0处理if !mm! lss 10 if !mm! gtr 0 set mm=0!mm!goto :eof:mm0set /a yyyy=!yyyy!-1set mm=12set od=31goto :eof 遗留问题本次处理遗漏了百年整除400才算闰年的情况，即该代码会在2100年3月1日产生bug，当天会生成一个21000229的文件，其实这个日期是不存在的，不过到时，我们可能早已不存在了，万一bug真留到那个时候 ，还是修改一下的好，哈哈！毕竟2200年3月1日以及2300年3月1日也会产生该bug！~~~ 补充20210901发生生产问题 ，因为之前未考虑到08,09作为月份也会被当做八进制处理报错。代码于20210901已修改。","categories":[],"tags":[{"name":"WORK","slug":"WORK","permalink":"https://devloperhu.gitee.io/tags/WORK/"}]},{"title":"搭建Spring本地调试环境","slug":"搭建Spring本地调试环境","date":"2021-03-14T16:02:55.000Z","updated":"2021-09-01T15:21:47.982Z","comments":true,"path":"posts/4588.html","link":"","permalink":"https://devloperhu.gitee.io/posts/4588.html","excerpt":"","text":"前情提要&emsp;&emsp;最近准备系统回顾下Spring框架，准备在本地进行搭建调试，过程中遇到一些坑，其实按照官方给出的搭建步骤进行就行。 准备步骤 下载Spring源码 安装gradle 安装IDEA 搭建步骤1.找到项目下的import-into-idea.md 2.根据指导预编译 spring-oxm和spring-core 新增build.gradle中仓库地址为阿里云仓库 12maven &#123; url &quot;https://maven.aliyun.com/repository/public&quot; &#125;maven &#123; url &quot;https://maven.aliyun.com/repository/gradle-plugin&quot; &#125; 4.将项目按照gradle进行导入idea中 5.等待依赖文件下载完成 6.写测试类进行测试，测试之前预编译 spring-oxm和spring-core","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://devloperhu.gitee.io/tags/Spring/"}]},{"title":"微服务商城项目（二）","slug":"微服务商城项目（二）","date":"2021-03-09T13:10:29.000Z","updated":"2021-03-20T02:08:54.159Z","comments":true,"path":"posts/57973.html","link":"","permalink":"https://devloperhu.gitee.io/posts/57973.html","excerpt":"","text":"环境搭建安装 linux 虚拟机项目背景谷粒商城项目是B2C（Business to Consumer）模式，即常见的供应商直接将商品卖给用户，也就是通常说的商业零售，如京东商城。 项目技术 下载&amp;安装 VirtualBox，要进入BIOS开启 CPU 虚拟化 下载&amp;安装 Vagrant https://app.vagrantup.com/boxes/search Vagrant 官方镜像仓库 https://www.vagrantup.com/downloads.html Vagrant 下载 打开 window cmd 窗口，运行 Vagrant init centos/7，即可初始化一个 centos7 系统 运行 vagrant up 即可启动虚拟机。系统 root 用户的密码是 vagrant 下载虚拟机比较慢，建议下载到本地后直接使用 cd 到下载好的文件目录，执行命令： 1vagrant box add centos&#x2F;7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box vagrant ssh：自动使用 vagrant 用户连接虚拟机。 修改 Vagrantfile中的ip改为物理机对应的ip ip最后一位修改一下（ps：不然后面连接MySQL会有问题），然后重启 查看ip： 安装 docker&emsp;&emsp;虚拟化容器技术。Docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。 1、卸载系统之前的 12345678docker sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2、安装 Docker-CE 安装必须的依赖 1sudo yum install -y yum-utils 设置 docker repo 的 yum 位置 123sudo yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo 安装 docker，以及 docker-cli 1sudo yum install docker-ce docker-ce-cli containerd.io 3、启动 docker 1sudo systemctl start docker 4、设置 docker 开机自启 1sudo systemctl enable docker 5、测试 docker 常用命令，注意切换到 root 用户下 https://docs.docker.com/engine/reference/commandline/docker/ 6、配置 docker 镜像加速 阿里云，容器镜像服务 针对 Docker 客户端版本大于 1.10.0 的用户 您可以通过修改 daemon 配置文件/etc/docker/daemon.json 来使用加速器 12345678sudo mkdir -p &#x2F;etc&#x2F;docker sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;82m9ar63.mirror.aliyuncs.com&quot;]&#125; EOF sudo systemctl daemon-reload sudo systemctl restart docker docker安装MySQL 1、下载镜像文件 1docker pull mysql:5.7 2、创建实例并启动 123456789101112docker run -p 3306:3306 --name mysql \\ -v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \\ -v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \\ -v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \\ -e MYSQL_ROOT_PASSWORD&#x3D;root \\ -d mysql:5.7 参数说明 -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口 -v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql：将配置文件夹挂载到主机 -v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql：将日志文件夹挂载到主机 -v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;：将配置文件夹挂载到主机 -e MYSQL_ROOT_PASSWORD&#x3D;root：初始化 root 用户的密码 MySQL 配置 1234567891011121314vi &#x2F;mydata&#x2F;mysql&#x2F;conf&#x2F;my.cnf [client] default-character-set&#x3D;utf8 [mysql] default-character-set&#x3D;utf8 [mysqld] init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39; init_connect&#x3D;&#39;SET NAMES utf8&#39; character-set-server&#x3D;utf8 collation-server&#x3D;utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve 注意：解决 MySQL 连接慢的问题在配置文件中加入如下，并重启 mysql 12[mysqld] skip-name-resolve 解释： skip-name-resolve：跳过域名解析 3、通过容器的 mysql 命令行工具连接 1docker exec -it mysql mysql -uroot -proot 4、设置 root 远程访问 123grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39; with grant option; flush privileges; 5、进入容器文件系统 1docker exec -it mysql&#x2F;bin&#x2F;bash docker 安装 redis 1、下载镜像文件 1docker pull redis 2、创建实例并启动 需要手动新建conf文件，不然挂载时会建一个文件夹 12mkdir -p &#x2F;mydata&#x2F;redis&#x2F;conf touch &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf 1234docker run -p 6379:6379 --name redis -v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \\ -v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \\ -d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf 在redis.conf配置AOF持久化 1appendonly yes 3、使用 redis 镜像执行 redis-cli 命令连接 1docker exec -it redis redis-cli","categories":[{"name":"Linux","slug":"Linux","permalink":"https://devloperhu.gitee.io/categories/Linux/"}],"tags":[{"name":"谷粒商城","slug":"谷粒商城","permalink":"https://devloperhu.gitee.io/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"}]},{"title":"微服务商城项目（一）","slug":"微服务商城项目（一）","date":"2021-03-07T09:59:35.000Z","updated":"2021-03-09T13:33:16.770Z","comments":true,"path":"posts/29199.html","link":"","permalink":"https://devloperhu.gitee.io/posts/29199.html","excerpt":"","text":"前情提要&emsp;&emsp;最近在公司参与微服务配置中心参数管理项目，想着关于微服务理论知识了解不少，但是还并没有机会完全实践去打通整个流程，因此就参照尚硅谷的谷粒商城项目从头到尾进行一次微服务项目的实际搭建过程。 项目背景谷粒商城项目是B2C（Business to Consumer）模式，即常见的供应商直接将商品卖给用户，也就是通常说的商业零售，如京东商城。 项目技术&amp;特色 前后分离开发，并开发基于 vue 的后台管理系统 SpringCloud 全新的解决方案 应用监控、限流、网关、熔断降级等分布式方案全方位涉及 分布式事务、分布式锁等分布式系统的难点 分析高并发场景的编码方式，线程池，异步编排等使用 压力测试与性能优化 各种集群技术的区别以及使用 CI/CD 使用 项目架构图 项目微服务架构图 微服务划分图 分布式基础概念 微服务 &emsp;&emsp;微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自 己的进程中，并使用轻量级机制通信，通常是 HTTP API。这些服务围绕业务能力来构建， 并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据 存储技术，并保持最低限度的集中式管理。 简而言之：拒绝大型单体应用，基于业务边界进行服务微化拆分，各个服务独立部署运行。 集群&amp;分布式&amp;节点 集群是个物理形态，分布式是个工作方式。 只要是一堆机器，就可以叫集群，他们是不是一起协作着干活，这个谁也不知道； 《分布式系统原理与范型》定义： “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统” ，分布式系统（distributed system）是建立在网络之上的软件系统。 分布式是指将不同的业务分布在不同的地方。 集群指的是将几台服务器集中在一起，实现同一业务。 例如：京东是一个分布式系统，众多业务运行在不同的机器，所有业务构成一个大型的业务集群。每一个小的业务，比如用户系统，访问压力大的时候一台服务器是不够的。我们就应该将用户系统部署到多个服务器，也就是每一个业务系统也可以做集群化； 分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。 节点：集群中的一个服务器。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://devloperhu.gitee.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"谷粒商城","slug":"谷粒商城","permalink":"https://devloperhu.gitee.io/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"}]},{"title":"如何快速搭建该博客","slug":"如何快速搭建该博客","date":"2021-02-21T15:46:13.000Z","updated":"2021-08-17T16:10:30.079Z","comments":true,"path":"posts/7720.html","link":"","permalink":"https://devloperhu.gitee.io/posts/7720.html","excerpt":"","text":"简介2021年02月21日晚更新。 基本环境 Window10 Node.js （点击进入官网下载） 在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。 选择Add to PATH然后点Next继续就行了。 然后在终端我们分别执行下面的命令验证： 12node -vnpm -v 安装cnpm 在git bash里面执行下面的命令，并检查： 12npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.orgcnpm -v Git（点击进入官网下载） 这个大家基本都有的。 安装Hexo (版本4.2.1) 在任意盘新建hexo文件夹并右键，选择Bit Bash Here 输入安装hexo命令 1npm install -g hexo-cli 接下来我们对hexo 进行初始化 1hexo init 到Install dependencies的时候你可能会卡住，这是大多数人基本都会遇到的 我们只需要在这里的时候结束命令，按Ctrl + c就可以结束命令 然后执行下面这个命令，就可以使用国内的镜像为你完成博客的初始化工作 1cnpm install 然后执行下面这个命令 12hexo g 或者hexo generatehexo s 或者hexo server 这样就可以到http://localhost:4000/ 查看了 如何下载使用主题 打开主题的项目地址后，点击Clone or download，然后复制https开头的地址 执行： 1git clone 复制的地址 themes&#x2F;主题名字 我本次使用的为：volantis 使用主题 在博客的目录下有一个叫_config.yml的文件 找到themes这一行，然后将主题名字修改为你的主题名 1theme: volantis 再次执行，就能看到你设置的新主题了 配置主题我们需要认识两个文件 站点配置文件 指的是博客根目录下的_config.yml 主题配置文件 指的是某个主题下的_config.yml 它们的名字都叫_config.yml但是你不能弄混淆 在我们看主题文档配置的时候，是必须要分清这两个概念的，不然会报错 参考文章：https://www.bilibili.com/read/cv9216631/","categories":[{"name":"Blog","slug":"Blog","permalink":"https://devloperhu.gitee.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://devloperhu.gitee.io/tags/Blog/"}]},{"title":"第一篇博客","slug":"第一篇博客","date":"2021-02-13T16:23:22.000Z","updated":"2022-02-27T14:29:04.589Z","comments":true,"path":"posts/59448.html","link":"","permalink":"https://devloperhu.gitee.io/posts/59448.html","excerpt":"","text":"简介&emsp;&emsp;前年的6月，我从传统制造企业裸辞，学习Java开发，后进入了武汉的一家外包公司，负责网络通讯运维管理的Java后端开发。 &emsp;&emsp;转行的这一年半内，我不仅在实践中夯实了编程技术，同时也为了下一次跳槽额外地做了些准备和补充学习，工作到去年的12月份(2020.12)，我跳槽来到上海（女朋友也在上海）的一家银行外包公司。目前想记录下这些经历，为了之后自我回顾，也激励自己不断地学习下去，能早日进入大厂。 背景介绍：某末流211工科本科，17年毕业在某家客车企业做了两年的工艺工程师，后转行Java，在一家外包做了1年时间，现入职上海一家银行外包。 我的目标：没有特定的公司，但是一定是大厂。进入大厂这个目标在我转行的时候就确定了，当时我的想法是，不管怎么样，先进入一家公司工作一两年的时间，然后跳槽大厂。大厂我在心里就是一线的腾讯，百度，阿里，字节，华为，二线的新浪，滴滴等等…，我想表达的是，如果你有这个进入大厂的目标，那么就要下定决心，这样好帮助你提早做好准备规划。 大厂要掌握的技能：这个从招聘要求中看不出来，因为大厂的招聘要求都是比较虚的，比如什么要有热情之类的，这些对我们没有帮助，有帮助的信息其实在牛客网，牛客网面经分为社招和校招，我们主要看社招，校招的可以参考看看。经过广泛阅读和筛选，我把要做的准备分为这四个部分： 算法题：大厂面试必考算法题，需要花大量时间去学习数据结构和刷算法题。 后端技术：大致是Spring Boot、Spring Cloud、Dubbo、ZooKeeper、Redis、MySQL、Kafka、RocketMQ、Docker以及分布式各种知识。 基础知识：计算机网络、计算机安全、操作系统(Linux)。 深挖项目：项目的亮点。 技能准备 算法题算法题其实应该完整称为：数据结构与算法。 第一步就是要先学习数据结构，比如队列，栈，二叉树。队列和栈就需要掌握添加，删减，插入元素的代码，而二叉树要掌握前序，中序，后序遍历（递归版本和不递归版本都要会，对算法学习有帮助），另外，只需要了解二叉搜索树、平衡二叉搜索树、红黑树、N叉树的区别优缺点，至于他们怎么保证平衡太复杂了，没兴趣可以不学。 第二步学习算法，这里的算法指的是排序算法，请掌握冒泡、堆排、归并、桶排、快排，尤其是归并，归并的思想在后面刷算法题中经常用到，桶排也是如此，空间换时间的思想在算法中很常见。这些排序算法请能够理解并且默写，知道他们的时间和空间复杂度，这些是基础，必须掌握。 第三步真正的算法题，这里的算法题指的是牛客网剑指offer和Leetcode中的题目，这些题目不是单纯的让你排序那么简单，他可能是让你用队列实现一个栈，可能是让你求出二叉树的深度，可能让你算出跳台阶的方法….，里面用到的思想就有，归并，递归，KMP，动态规划等等(我用到的也就这么多…，还有什么广度优先，深度优先…)。 &emsp;&emsp;剑指offer可以认为是算法题入门，并不是说它很简单，而是他的解法很常见。Leetcode建议不要全部做，可以先去搜索各个大厂面经，把它们的算法题记下来，然后去Leetcode一个一个去刷，这样针对性是最强的。最后，什么时候学习算法呢？应该放在准备期间的后半段时间，因为算法题还是需要一些手感的，在求职的时候保持算法手感有一定作用。 后端技术&emsp;&emsp;Java主要的就是这些技术：大致是spring Boot、Spring Cloud、Dubbo、ZooKeeper、Redis、MySQL、Kafka、RocketMQ、Docker、分布式、JVM、并发编程。 &emsp;&emsp;Spring Cloud我是学习社交项目这个视频的，这个视频几乎包含了目前互联网企业常用的技术，其中必须要会的是redis、eureka、feign、docker、hystrix、zuul。掌握这些使用，应该要学习2个月时间。另外的比如mongDB、es、jenkins可以根据需要进行学习。其次vue可以学习一下，这种前端框架学习之后对理解目前的前端技术是有用的。Dubbo、ZooKeeper这两个和Spring Cloud是不同的微服务框架，需要单独学习。我是学习的尚硅谷这个视频，在学习Dubbo的时候其实就会涉及到ZooKeeper的使用，但是上面的视频中讲ZooKeeper比较浅显，深入学习ZooKeeper推荐看尚硅谷这个视频。这里再次感谢尚硅谷的优质的教程，帮助很大。 &emsp;&emsp;redis的话，大家在B站找个播放量高的效果大差不差。主要掌握redis 的基本数据结构、持久化、哨兵、集群、主从复制这几个关键点，另外推荐掌握zset的数据结构底层实现，编码方式，会是一个亮点。 &emsp;&emsp;MySQL需要额外了解日志系统、锁原理、索引原理、隔离、主从延时等等，帮助非常大。算是对于Mysql的进阶学习。 &emsp;&emsp;Kafka需要了解Kafka的Rebalance机制，主从同步机制，选主机制等等。 &emsp;&emsp;docker推荐尚硅谷的，对于docker不用特别精通，知道有docker这样的容器，他的作用是什么，优点是什么就行。 &emsp;&emsp;另外我是搞JAVA的，需要单独掌握JVM的知识，包括垃圾回收器的种类、垃圾回收算法、锁的底层实现原理、JMM内存模型…..另外还要学习并发编程，包括AQS，原生锁，乐观锁、线程池、LOCK、并发工具类….这些也可以从网上 找到相应的知识去学习。 &emsp;&emsp;分布式理论，这部分东西比较杂乱，包括基本的CAP、BASE理论，限流、降级、熔断、主从一致算法(raft，hash一致..)、分布式锁、分布式事务、缓存和数据库一致性问题、选主算法等等，没有固定一个教学视频，都是东找找，西找找拼凑起来的。 &emsp;&emsp;最后要说的是，这部分内容学什么要因人而异，我工作的项目微服务涉及较少，所以花了很多时间来掌握这些微服务的知识，如果你目前的公司业务中用到有这里的技术，那其实就可以省略掌握相应的部分。这部分的学习需要花费3-4个月的时间。 基础知识&emsp;&emsp;基础知识包括了计算机网络，比如TCP三次握手和四次挥手，五层结构，http报文结构，https请求过程等等；也包括了计算机安全，比如各种网络攻击XSS、跨域攻击、sql注入等等；也包括操作系统，比如内核态用户态的区别、进程怎么通讯、线程和进程的区别、IO的类型、多路复用等等。最后还包括Linux的常见命令。这些因为我不是计算机专业所以比较薄弱，花了一两个月时间进行学习，主要就是看面经然后找博客，进而拓展学习。 &emsp;&emsp;最后以上三点的内容学习完后，强推用这位同学的总结来检查自己学习的结果，你也可以根据这个总结来反推学习内容。当你能百分百回答上这些问题的时候，就差不多可以去面试了。 项目深挖&emsp;&emsp;这个因人而异了，回顾一年的工作，找出最亮眼的工作，亮眼的意思是，你独立完成，或者从无到有，或者提高性能多少，或者排查解决了什么重大生产事故等等。因为面试必会问“你做的最有挑战的一个技术难点是什么？你需要准备好。我的跳槽求职简历也是基于工作亮点来书写的。 &emsp;&emsp;最后，我始终觉得，不管有多大的目标，只要是做好时间规划，内容规划，然后咬牙坚持一步步走下去，最后一定会收获想要的东西。愿大家都能收获自己的果实。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://devloperhu.gitee.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-02-12T15:45:23.000Z","updated":"2022-02-27T14:33:09.631Z","comments":true,"path":"posts/16107.html","link":"","permalink":"https://devloperhu.gitee.io/posts/16107.html","excerpt":"","text":"&emsp;&emsp;来上海两个多月了，新的工作也开始了一个多月。 &emsp;&emsp;之前在搜一些技术问题的时候，发现很多大佬都有自己的博客。加上偶尔发现我的发小“老千哥”自己也搭建了博客，用于记录平常的工作问题以及个人的想法，所以我一直也想建立一个属于自己的博客。但是前段时间在上家公司加班有点严重，加上为了找工作复习、投简历，所以没时间搞这件事儿。现在项目不算忙，所以就抽出时间搞了一个属于自己的博客，用来记录下自己的工作上和平时学习上的问题。 &emsp;&emsp;本次博客才用的是Hexo进行搭建的，主题用的是volantis魔改版Volantis-heson。按照作者的指导搭建好之后，将其部署在了GitHub Pages上。 &emsp;&emsp;曾经问过一个大佬在学习上又没有什么习惯或者技巧，他说“我每当解决一个问题之后都会总结并记录下来”。是的自己也深有体会，每次百度半天解决的问题，不做记录的话过一段时间，再遇到一样会去百度半天，可能这就是平常人与大佬们的区别吧。希望自己也能坚持学习，并将解决问题的方法或新学习到的知识记录下来，将来也能成为一个“大佬”，哈哈！ &emsp;&emsp;以某某大佬的一句话作为结尾，以此共勉： &emsp;&emsp;“对任何渴望进步的人来说，写博客/文章/回答对自己的成长帮助都是巨大的。频率和数量不必过分强求，有话要说就写写，没事就歇歇，随意点。因为坚持写作的那一刻起，你就已经开始受益。”","categories":[{"name":"杂记","slug":"杂记","permalink":"https://devloperhu.gitee.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Linux","slug":"Linux","permalink":"https://devloperhu.gitee.io/categories/Linux/"},{"name":"微服务","slug":"微服务","permalink":"https://devloperhu.gitee.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Blog","slug":"Blog","permalink":"https://devloperhu.gitee.io/categories/Blog/"},{"name":"杂记","slug":"杂记","permalink":"https://devloperhu.gitee.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://devloperhu.gitee.io/tags/Spring/"},{"name":"Java基础","slug":"Java基础","permalink":"https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"WORK","slug":"WORK","permalink":"https://devloperhu.gitee.io/tags/WORK/"},{"name":"谷粒商城","slug":"谷粒商城","permalink":"https://devloperhu.gitee.io/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"},{"name":"Blog","slug":"Blog","permalink":"https://devloperhu.gitee.io/tags/Blog/"}]}