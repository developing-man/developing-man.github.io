<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丁满博客 - Hexo博客</title>
  
  
  <link href="https://devloperhu.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://devloperhu.gitee.io/"/>
  <updated>2022-02-27T13:56:04.032Z</updated>
  <id>https://devloperhu.gitee.io/</id>
  
  <author>
    <name>胖胖的丁满</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring之属性注入</title>
    <link href="https://devloperhu.gitee.io/posts/39762.html"/>
    <id>https://devloperhu.gitee.io/posts/39762.html</id>
    <published>2021-12-19T07:43:07.000Z</published>
    <updated>2022-02-27T13:56:04.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><p>spring的依赖注入方式分为分别是基于构造方法和基于setter。以下是<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies">Spring官网</a>原话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DI exists in two major variants: Constructor-based dependency injection and Setter-based dependency injection.</span><br></pre></td></tr></table></figure><p>DI存在两个<strong>主要变体</strong>：基于<strong>构造函数</strong>的依赖注入和基于<strong>Setter</strong>的依赖注入。</p><p>而装配方式又分为手动装配和自动装配，但是不管是手动装配还是自动装配都是基于这两种方式或者变体方式来的。有的注入方式就不是这两种，而是这两种其中一种的变体方式；比如在一个类的属性上面加@Autowired，这种方式注入属性的方式就是利用了java的反射知识,@Autowired这种注入的方式是setter注入方式的一种变体</p><h2 id="手动装配"><a href="#手动装配" class="headerlink" title="手动装配"></a>手动装配</h2><p>在spring应用程序当中假设你的A类依赖了B类. 需要在A类当中提供一个B类的属性, 再加上setter, 继而在xml当中配置、描述一下这两个类之间的依赖关系. 如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；这种由程序员自己配置、描述好依赖关系的写法叫做手动装配。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   B b;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 测试set注入</span></span><br><span class="line">   <span class="comment">// public void setB(B b) &#123;</span></span><br><span class="line">   <span class="comment">//    this.b = b;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 测试构造方法注入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.b = b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> B <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;获取的B对象：&quot;</span> + b);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line">      context.getBean(A.class).getB();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.autowired.A&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- set注入 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;property name=&quot;b&quot; ref=&quot;b&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 构造方法注入 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.autowired.B&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>自动注入的出现是因为手动装配过于麻烦，比如某个类X当中依赖了10个其他类那么配置文件将会变的特别冗余和臃肿，spring的做法是可以为这个X类提供一种叫做<strong>自动装配的模型</strong>，无需程序员去手动配置X类的依赖关系。</p><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   D d;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 测试setter方法注入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setD</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.d = d;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 测试构造方法注入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.d = d;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;获取的D对象：&quot;</span> + d);</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ClassPathXmlApplicationContext context = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line">      context.getBean(A.class).getD();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动装配模式-（Autowiring-modes）"><a href="#自动装配模式-（Autowiring-modes）" class="headerlink" title="自动装配模式 （Autowiring modes）"></a>自动装配模式 （Autowiring modes）</h3><table><thead><tr><th align="left">模式</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>no</code></td><td align="left">（默认）没有自动装配。Bean 引用必须由<code>ref</code>元素定义。对于较大的部署，不建议更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</td></tr><tr><td align="left"><code>byName</code></td><td align="left">按属性名称自动装配。Spring 查找与需要自动装配的属性同名的 bean。例如，如果一个 bean 定义被设置为按名称自动装配并且它包含一个<code>master</code>属性（即它有一个 <code>setMaster(..)</code>方法），Spring 会查找一个名为<code>master</code>的 bean 定义并使用它来设置属性。</td></tr><tr><td align="left"><code>byType</code></td><td align="left">如果容器中恰好存在一个属性类型的 bean，则让属性自动装配。如果存在多个，则会引发致命异常，这表明您不能<code>byType</code>为该 bean使用自动装配。如果没有匹配的 bean，则不会发生任何事情（未设置属性）。</td></tr><tr><td align="left"><code>constructor</code></td><td align="left">类似于<code>byType</code>但适用于构造函数参数。如果容器中没有一个构造函数参数类型的 bean，则会引发致命错误。</td></tr></tbody></table><p>自动注入模式和前面提到的依赖注入方式(setter和构造方法)是两回事，简单说:依赖注入是一个过程，主要通过setter和构造方法以及一些变体的方式完成把对象依赖、或者填充上的这个过程叫做依赖注入，不管手动装配还是自动装配都有这个过程；而自动装配模式是一种完成自动装配依赖的手段体现，每一种模型都使用了不同的技术去查找和填充bean；而从spring官网上面可以看到spring只提出了4中自动装配模式,(第一种是no，表示不使用自动装配.)。</p><p>这四个模式分别用一个整型来表示，存在spring的beanDefinition当中，任何一个类默认是no这个装配模式，也就是一个被注解的类默认的装配模型是no也就是手动装配；需要注意的是官网上面说的四种注入模型其中并没有我们熟悉的**@Autowired**，这也再一次说明@Autowired不是自动装配。</p><p>假设在TestService类的某个属性上面加上@Autowired之后这个TestService类会不会成了自动装配呢？@Autowired是不是会改变这个类A当中的autowireMode呢？<br>答案是不会的，可以<strong>自定义一个spring后置处理器</strong>，去取出设置了@Autowired的beanDefinition，然后获取AutowireMode，会发现一直是0。说明这个类不是自动装配，其实这已经能证明<code>@Autowried</code>不是自动装配了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;依赖注入的方式&quot;&gt;&lt;a href=&quot;#依赖注入的方式&quot; class=&quot;headerlink&quot; title=&quot;依赖注入的方式&quot;&gt;&lt;/a&gt;依赖注入的方式&lt;/h2&gt;&lt;p&gt;spring的依赖注入方式分为分别是基于构造方法和基于setter。以下是&lt;a href=&quot;http</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java日志到Spring日志浅析</title>
    <link href="https://devloperhu.gitee.io/posts/35037.html"/>
    <id>https://devloperhu.gitee.io/posts/35037.html</id>
    <published>2021-12-11T00:52:55.000Z</published>
    <updated>2021-12-12T06:20:27.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a><strong>前情提要</strong></h2><p>&emsp;&emsp;最近log4j2在安全圈爆出严重漏洞问题，就发觉自己对Java日志体系了解的有点模糊。平时工作只知道复用已有的日志框架，然后打印日志就行，对于为什么会有log4j及slf4j都不太清楚，因此花点时间完善一下这块知识。</p><h2 id="日志产品介绍"><a href="#日志产品介绍" class="headerlink" title="日志产品介绍"></a><strong>日志产品介绍</strong></h2><p><strong>JDK Logging</strong>：Java标准库内置的日志包 java.util.logging，以下简称jul。</p><p><strong>log4j</strong>：一种非常流行的日志框架，最新版本是2.x。</p><p><strong>commons-logging</strong>：简称jcl，它是一个第三方的日志库，由Apache创建的日志模块。特点是可以挂接不同的日志系统，可以根据配置文件指定挂接的日志系统。默认情况下，jcl自动搜索并使用log4j,如果过没找到log4j,再使用JDK Logging。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 内部硬编码维护了一个常用log日志全类名数组</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] classesToDiscover = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">           <span class="string">&quot;org.apache.commons.logging.impl.Log4JLogger&quot;</span>,</span><br><span class="line">           <span class="string">&quot;org.apache.commons.logging.impl.Jdk14Logger&quot;</span>,</span><br><span class="line">           <span class="string">&quot;org.apache.commons.logging.impl.Jdk13LumberjackLogger&quot;</span>,</span><br><span class="line">           <span class="string">&quot;org.apache.commons.logging.impl.SimpleLog&quot;</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历该数组，去获取用户调用的LOG</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classesToDiscover.length &amp;&amp; result == <span class="keyword">null</span>; ++i) &#123;</span><br><span class="line">       result = <span class="keyword">this</span>.createLogFromClass(classesToDiscover[i], logCategory, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       c = Class.forName(logAdapterClassName, <span class="keyword">true</span>, currentCL);</span><br><span class="line">   &#125; <span class="keyword">catch</span> ( ) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   constructor = c.getConstructor(<span class="keyword">this</span>.logConstructorSignature);</span><br><span class="line">   Object o = constructor.newInstance(params);</span><br></pre></td></tr></table></figure><p>　　前面介绍了Commons Logging和Log4j，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。还有<strong>SLF4J</strong>(The Simple Logging Facade for Java)和<strong>Logback</strong>，其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p><p><strong>SLF4J</strong>提供了绑定器与各类实现它的日志框架结合进行使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- logback-绑定器 包含了核心和slf4j 以及logback的绑定器 三个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- slf4j-log4j1 绑定器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- log4j2-slf4j-impl 绑定器 绑定log4j2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SLF4J</strong>还提供了桥接器来解决历史日志硬编码问题：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j2桥接器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- log4j-over-slf4j log4j1的桥接器 不能和log4j1的核心共存会有jar冲突问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p><h2 id="spring日志"><a href="#spring日志" class="headerlink" title="spring日志"></a><strong>spring日志</strong></h2><p>&emsp;&emsp;spring 4.x 及以前版本基本采用jcl，扩展机制根据用户手动依赖的日志产品进行挂接，改变spring默认日志框架。spring 5.x 版本后，自己搞了一个spring-jcl的module。</p><p>spring默认更支持使用log4j，可看源码得知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 创建Log时依据用户指定枚举值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">createLog</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (logApi) &#123;</span><br><span class="line">         <span class="keyword">case</span> LOG4J:</span><br><span class="line">            <span class="keyword">return</span> Log4jAdapter.createLog(name);</span><br><span class="line">         <span class="keyword">case</span> SLF4J_LAL:</span><br><span class="line">            <span class="keyword">return</span> Slf4jAdapter.createLocationAwareLog(name);</span><br><span class="line">         <span class="keyword">case</span> SLF4J:</span><br><span class="line">            <span class="keyword">return</span> Slf4jAdapter.createLog(name);</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> JavaUtilAdapter.createLog(name);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类初始化时即读取用户指定的依赖，判断最终用哪种日志框架打印spring日志</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isPresent(LOG4J_SPI)) &#123;</span><br><span class="line"><span class="comment">// 若只依赖了slf4j还不够，还要指定使用org.apache.logging.slf4j.SLF4JProvider</span></span><br><span class="line"><span class="comment">// 此类只存在于log4j-to-slf4j桥接器中</span></span><br><span class="line"><span class="comment">// 若spring或其它第三方jar包默认指定log4j2，则会去使用log4j</span></span><br><span class="line"><span class="comment">// 要彻底只想用slf4j的话，在项目中加入log4j-to-slf4j，则此处判定通过</span></span><br><span class="line"><span class="keyword">if</span> (isPresent(LOG4J_SLF4J_PROVIDER) &amp;&amp; isPresent(SLF4J_SPI)) &#123;</span><br><span class="line">logApi = LogApi.SLF4J_LAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logApi = LogApi.LOG4J;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isPresent(SLF4J_SPI)) &#123;</span><br><span class="line">logApi = LogApi.SLF4J_LAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isPresent(SLF4J_API)) &#123;</span><br><span class="line">logApi = LogApi.SLF4J;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// jcl作为最后默认的日志体系</span></span><br><span class="line">logApi = LogApi.JUL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring-boot日志"><a href="#spring-boot日志" class="headerlink" title="spring-boot日志"></a><strong>spring-boot日志</strong></h2><p>springBoot中将日志进行了统一，对于spring的默认log4j2也好，对于tomcat的jcl也好，最终都用slf4j下的logback去实现统一的打印，其原理就类似上面解决用slf4j统一打印spring的日志。</p><p><img src="https://cdn.jsdelivr.net/gh/developing-man/ImgHosting/TIMON-PIC/springboot%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/developing-man/ImgHosting/TIMON-PIC/springboot%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="springboot日志结构"></p><ul><li><p>ch.qos.logback:logback-classic:1.2.3</p><p>其作用就是选定slf4j、引入logback、并绑定二者，因此在springboot中可以去使用logback日志</p></li><li><p>org.apache.logging.log4j:log4j-to-slf4j:2.13.3</p><p>其作用就是将spring及其他第三方jar包中依赖的log4j2给桥接转换为slf4j</p></li><li><p>org.slf4j:jul-to-slf4j:1.7.30</p><p>在tomcat中，其日志用jcl实现的，此桥接器可以统一此类第三方jar包的日志</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;&lt;strong&gt;前情提要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近log4j2在安全圈爆出严重漏洞问题，就发觉自己对Java日志</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://devloperhu.gitee.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>死磕JDK源码-CopyOnWriteArrayList</title>
    <link href="https://devloperhu.gitee.io/posts/8763.html"/>
    <id>https://devloperhu.gitee.io/posts/8763.html</id>
    <published>2021-04-16T13:29:11.000Z</published>
    <updated>2022-03-28T11:57:49.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现，每次对数组的修改都完全拷贝一份新的数组来修改，修改完了再替换掉老数组，这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。</p><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p>同ArrayList，CopyOnWriteArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 用于修改时加锁 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 真正存储元素的地方，只能通过getArray()/setArray()访问 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>（1）lock</p><p>用于修改时加锁，使用transient修饰表示不自动序列化。</p><p>（2）array</p><p>真正存储元素的地方，使用transient修饰表示不自动序列化，使用volatile修饰表示一个线程对这个字段的修改另外一个线程立即可见。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现，每次对数组的修改都完全拷贝一份新的数组来修</summary>
      
    
    
    
    <category term="JDK源码" scheme="https://devloperhu.gitee.io/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java集合" scheme="https://devloperhu.gitee.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>死磕JDK源码-ArrayList</title>
    <link href="https://devloperhu.gitee.io/posts/57469.html"/>
    <id>https://devloperhu.gitee.io/posts/57469.html</id>
    <published>2021-04-15T14:35:58.000Z</published>
    <updated>2022-03-28T09:05:37.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ArrayList是一种以数组实现的List，与数组相比，它具有动态扩展的能力，因此也可称之为动态数组。</p><p>面试常见问题：</p><ul><li><p>ArrayList是怎么扩容的？</p><p>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList删除元素不会进行缩容；</p></li><li><p>ArrayList插入、删除、查询元素的时间复杂度各是多少？</p><p>插入尾部O(1)，中间O(n)；删除尾部尾部O(1)，中间O(n)；查询O(1)；</p></li><li><p>怎么求两个集合的并集、交集、差集？</p><p> <code>addAll(Collection&lt;?&gt; c)</code>、<code>retainAll(Collection&lt;?&gt; c)</code>、 <code>removeAll(Collection&lt;?&gt; c)</code></p></li><li><p>ArrayList是怎么实现序列化和反序列化的？</p><p>见最后的序列化读写方法writeObject、readObject</p></li><li><p>集合的方法toArray()有什么问题？</p><p>一般来说Collection的<code>Object[] toArray()</code>方法默认返回的是Object类型，但是如果某类继承了Collection 类并重写了toArray方法，并指定其他类型，则该方法返回的就不一定是Object类型了；</p></li></ul><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="https://cdn.jsdelivr.net/gh/developing-man/ImgHosting/TIMON-PIC/20220323222151.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/developing-man/ImgHosting/TIMON-PIC/20220323222151.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="ArrayList继承关系图"></p><p>ArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。</p><p>ArrayList实现了List，提供了基础的添加、删除、遍历等操作。</p><p>ArrayList实现了RandomAccess，提供了随机访问的能力。</p><p>ArrayList实现了Cloneable，可以被克隆。</p><p>ArrayList实现了Serializable，可以被序列化。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组，如果传入的容量为0时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组，传入容量时使用，添加第一个元素的时候会重新初始为默认容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储元素的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合中元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>（1）DEFAULT_CAPACITY</p><p>默认容量为10，也就是通过new ArrayList()创建时的默认容量。</p><p>（2）EMPTY_ELEMENTDATA</p><p>空的数组，这种是通过new ArrayList(0)创建时用的是这个空数组。</p><p>（3）DEFAULTCAPACITY_EMPTY_ELEMENTDATA</p><p>也是空数组，这种是通过new ArrayList()创建时用的是这个空数组，与EMPTY_ELEMENTDATA的区别是在添加第一个元素时使用这个空数组的会初始化为DEFAULT_CAPACITY = 10个元素。</p><p>（4）elementData</p><p>真正存放元素的地方，使用transient是为了不序列化这个字段。</p><p><em>private表示是类私有的属性，只要是在这个类内部都可以访问，嵌套类或者内部类也是在类的内部，所以也可以访问类的私有成员。</em></p><p>（5）size</p><p>真正存储元素的个数，而不是elementData数组的长度。</p><h3 id="ArrayList-int-initialCapacity-构造方法"><a href="#ArrayList-int-initialCapacity-构造方法" class="headerlink" title="ArrayList(int initialCapacity)构造方法"></a>ArrayList(int initialCapacity)构造方法</h3><p>传入初始容量，如果大于0就初始化elementData为对应大小，如果等于0就使用EMPTY_ELEMENTDATA空数组，如果小于0抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量大于0，就新建一个数组存储元素</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量等于0，使用空数组EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果传入的初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList-构造方法"><a href="#ArrayList-构造方法" class="headerlink" title="ArrayList()构造方法"></a>ArrayList()构造方法</h3><p>不传初始容量，初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA空数组，会在添加第一个元素的时候扩容为默认的大小，即10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有传入初始容量，则使用空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="comment">// 使用这个数组是在添加第一个元素的时候会扩容到默认大小10</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList-Collection-lt-extends-E-gt-c-构造方法"><a href="#ArrayList-Collection-lt-extends-E-gt-c-构造方法" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)构造方法"></a>ArrayList(Collection&lt;? extends E&gt; c)构造方法</h3><p>传入集合并初始化elementData，这里会使用拷贝把传入集合的元素拷贝到elementData数组中，如果元素个数为0，则初始化为EMPTY_ELEMENTDATA空数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把传入集合的元素初始化到ArrayList中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合转数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果c的空集合，则初始化为空数组EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么<code>c.toArray()</code>返回的有可能不是Object[]类型呢？</p><p>一般来说Collection的<code>Object[] toArray()</code>方法默认返回的是Object类型，但是如果某类继承了Collection 类并重写了toArray方法，并指定其他类型，则该方法返回的就不一定是Object类型了。请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father[] fathers = <span class="keyword">new</span> Son[]&#123;&#125;;</span><br><span class="line">        <span class="comment">// 打印结果为class [Lcom.coolcoding.code.Son;</span></span><br><span class="line">        System.out.println(fathers.getClass());</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> MyList();</span><br><span class="line">        <span class="comment">// 打印结果为class [Ljava.lang.String;</span></span><br><span class="line">        System.out.println(strList.toArray().getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类重写父类的方法，返回值可以不一样</span></span><br><span class="line"><span class="comment">     * 但这里只能用数组类型，换成Object就不行</span></span><br><span class="line"><span class="comment">     * 应该算是java本身的bug</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] toArray() &#123;</span><br><span class="line">        <span class="comment">// 为了方便举例直接写死</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h3><p>添加元素到末尾，平均时间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 把元素插入到最后一位</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新容量发现比需要的容量还小，则以需要的容量为准</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量已经超过最大容量了，则使用最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 以新容量拷贝出来一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）检查是否需要扩容；</p><p>（2）如果elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA则初始化容量大小为DEFAULT_CAPACITY；</p><p>（3）新容量是老容量的1.5倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；</p><p>（4）创建新容量的数组并把老数组拷贝到新数组；</p><h3 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h3><p>添加元素到指定位置，平均时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将inex及其之后的元素往后挪一位，则index位置处就空出来了</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 将元素插入到index的位置</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 大小增1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）检查索引是否越界；</p><p>（2）检查是否需要扩容；</p><p>（3）把插入索引位置后的元素都往后挪一位；</p><p>（4）在插入索引位置放置插入的元素；</p><p>（5）大小加1；</p><h3 id="addAll-Collection-lt-extends-E-gt-c-方法"><a href="#addAll-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)方法"></a>addAll(Collection&lt;? extends E&gt; c)方法</h3><p>求两个集合的并集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将集合c中所有元素添加到当前ArrayList中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将集合c转为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);</span><br><span class="line">    <span class="comment">// 将c中元素全部拷贝到数组的最后</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    <span class="comment">// 大小增加c的大小</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 如果c不为空就返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）拷贝c中的元素到数组a中；</p><p>（2）检查是否需要扩容；</p><p>（3）把数组a中的元素拷贝到elementData的尾部；</p><h3 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h3><p>获取指定索引位置的元素，时间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 返回数组index位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）检查索引是否越界，这里只检查是否越上界，如果越上界抛出IndexOutOfBoundsException异常，如果越下界抛出的是ArrayIndexOutOfBoundsException异常。</p><p>（2）返回索引位置处的元素；</p><h3 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h3><p>删除指定索引位置的元素，时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取index位置的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果index不是最后一位，则将index之后的元素往前挪一位</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将最后一个元素删除，帮助GC</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）检查索引是否越界；</p><p>（2）获取指定索引位置的元素；</p><p>（3）如果删除的不是最后一位，则其它元素往前移一位；</p><p>（4）将最后一位置为null，方便GC回收；</p><p>（5）返回删除的元素。</p><p><em>可以看到，ArrayList删除元素的时候并没有缩容。</em></p><h3 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h3><p>删除指定元素值的元素，时间复杂度为O(n)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br><span class="line">        for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">            &#x2F;&#x2F; 如果要删除的元素为null，则以null进行比较，使用&#x3D;&#x3D;</span><br><span class="line">            if (elementData[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br><span class="line">        for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">            &#x2F;&#x2F; 如果要删除的元素不为null，则进行比较，使用equals()方法</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 少了一个越界的检查</span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; 如果index不是最后一位，则将index之后的元素往前挪一位</span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    &#x2F;&#x2F; 将最后一个元素删除，帮助GC</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）找到第一个等于指定元素值的元素；</p><p>（2）快速删除；</p><p><em>fastRemove(int index)相对于remove(int index)少了检查索引越界的操作，可见jdk将性能优化到极致。</em></p><h3 id="retainAll-Collection-lt-gt-c-方法"><a href="#retainAll-Collection-lt-gt-c-方法" class="headerlink" title="retainAll(Collection&lt;?&gt; c)方法"></a>retainAll(Collection&lt;?&gt; c)方法</h3><p>求两个集合的交集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合c不能为null</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="comment">// 调用批量删除方法，这时complement传入true，表示删除不包含在c中的元素</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 批量删除元素</span></span><br><span class="line"><span class="comment">* complement为true表示删除c中不包含的元素</span></span><br><span class="line"><span class="comment">* complement为false表示删除c中包含的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="comment">// 使用读写两个指针同时遍历数组</span></span><br><span class="line">    <span class="comment">// 读指针每次自增1，写指针放入元素的时候才加1</span></span><br><span class="line">    <span class="comment">// 这样不需要额外的空间，只需要在原有的数组上操作就可以了</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历整个数组，如果c中包含该元素，则把该元素放到写指针的位置（以complement为准）</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 正常来说r最后是等于size的，除非c.contains()抛出了异常</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            <span class="comment">// 如果c.contains()抛出了异常，则把未读的元素都拷贝到写指针之后</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// 将写指针之后的元素置为空，帮助GC</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            <span class="comment">// 新大小等于写指针的位置（因为每写一次写指针就加1，所以新大小正好等于写指针的位置）</span></span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有修改返回true</span></span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）遍历elementData数组；</p><p>（2）如果元素在c中，则把这个元素添加到elementData数组的w位置并将w位置往后移一位；</p><p>（3）遍历完之后，w之前的元素都是两者共有的，w之后（包含）的元素不是两者共有的；</p><p>（4）将w之后（包含）的元素置为null，方便GC回收；</p><h3 id="removeAll-Collection-lt-gt-c"><a href="#removeAll-Collection-lt-gt-c" class="headerlink" title="removeAll(Collection&lt;?&gt; c)"></a>removeAll(Collection&lt;?&gt; c)</h3><p>求两个集合的单方向差集，只保留当前集合中不在c中的元素，不保留在c中不在当前集体中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合c不能为空</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="comment">// 同样调用批量删除方法，这时complement传入false，表示删除包含在c中的元素</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与retainAll(Collection&lt;?&gt; c)方法类似，只是这里保留的是不在c中的元素。</p><h3 id="writeObject-ObjectOutputStream-s"><a href="#writeObject-ObjectOutputStream-s" class="headerlink" title="writeObject(ObjectOutputStream s)"></a>writeObject(ObjectOutputStream s)</h3><p><em>elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有修改，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 声明为空数组</span></span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        </span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p><p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p><p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p><p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList删除元素不会进行缩容；</p><p>（2）ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；</p><p>（3）ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；</p><p>（4）ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；</p><p>（5）ArrayList从尾部删除元素极快，时间复杂度为O(1)；</p><p>（6）ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；</p><p>（7）ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可；</p><p>（8）ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可；</p><p>（7）ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;ArrayList是一种以数组实现的List，与数组相比，它具有动态扩展的能力，因此也可称之为动态数组。&lt;/p&gt;
&lt;p&gt;面试常见问题：&lt;/p</summary>
      
    
    
    
    <category term="JDK源码" scheme="https://devloperhu.gitee.io/categories/JDK%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java集合" scheme="https://devloperhu.gitee.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>关于网络那些事儿</title>
    <link href="https://devloperhu.gitee.io/posts/1486.html"/>
    <id>https://devloperhu.gitee.io/posts/1486.html</id>
    <published>2021-04-14T12:48:24.000Z</published>
    <updated>2022-03-13T09:02:22.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四层模型和七层模型"><a href="#四层模型和七层模型" class="headerlink" title="四层模型和七层模型"></a><strong>四层模型和七层模型</strong></h2><p>OSI七层模型，就是搞一个标准的网络模型出来，大家都按照这个来走，那么大家都有统一的规范。</p><p>OSI七层模型：<strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>数据链路层</strong>、<strong>物理层</strong>。</p><p>TCP/IP四层模型：<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong>、<strong>应用层</strong>。</p><h2 id="从底向上的网络分层"><a href="#从底向上的网络分层" class="headerlink" title="从底向上的网络分层"></a><strong>从底向上的网络分层</strong></h2><ul><li><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4></li></ul><p>物理层，就是电脑之间要联网，N年前，都是在电脑上插根线是吧，然后才能上网，现在就是联个wifi就行了，还有中国美国之前联网靠的是海底的光缆。所以物理层就指的这个，就是怎么把各个电脑给联结起来，形成一个网络，这就是物理层的含义，物理层负责传输0和1的电路信号。计算机的最最底层，就是0/1，电信号。</p><ul><li><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><strong>数据链路层</strong></h4></li></ul><p>数据链路层，物理层给各个电脑连接起来了，还传输最底层的0和1电路信号，得定义清楚哪些0和1分为一组，这些信号啥意思？这才能进行通信。所以数据链路层就干这事儿，定义一下电路信号咋分组。</p><p>很多年前，每个公司都定义自己的电路信号分组方式，但是后来出来了<strong>以太网协议</strong>，以太网。一组电信号是一个数据包，叫一个帧（frame），每个帧分成两个部分，<strong>标头</strong>（head）和<strong>数据</strong>（data），标头包含一些说明性的东西，比如说发送者、接收者和数据类型之类的。</p><p>以太网协议规定了，接入网络里的所有设备，都得有个<strong>网卡</strong>，以太网协议里的那个数据包，在数据链路层传输的数据包，必须从一个电脑的网卡传输到另外一个电脑的网卡，而这个网卡地址就叫做所谓的<strong>mac地址</strong>。每块网卡出厂的时候，就有一个唯一的mac地址，48位的二进制，但是一般用12个16进制数字表示，前6个16进制是厂商编号，后6个16进制是网卡流水号。</p><p>所以在以太网里传输数据包的时候，必须指定接收者的mac地址才能传输数据。</p><p>但是以太网的数据包怎么从一个mac地址发送到另一个mac地址？这个不是精准推送的，以太网里面，如果一个电脑发个数据包出去，会<strong>广播</strong>给<strong>局域网</strong>内的所有电脑设备的网卡，然后每台电脑都从数据包里获取接收者的mac地址，跟自己的mac地址对比一下，如果一样，就说明这是发给自己的数据包。但是这种广播的方式，仅仅针对一个子网（局域网）内的电脑，会广播，仅仅广播给一个子网里面的电脑的。</p><ul><li><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4></li></ul><p>子网内的电脑，通过以太网发个数据包，对局域网内的电脑，是广播出去的。那么怎么知道哪些电脑在一个子网内呢？这就得靠网络层了，这里就有一套IP地址，IP地址就可以让我们区分哪些电脑是一个子网的。</p><p>网络层里有IP协议，IP协议定义的地址就叫做IP地址。IP地址有IPv4和IPv6两个版本，目前广泛使用的是IPv4，是32个二进制数字组成的，但是一般用4个十进制数字表示，范围从0.0.0.0到255.255.255.255之间。</p><p>每台计算机，都会分配一个ip地址，ip地址的前24位（就是前面3个十进制数字），代表了网络，后8位（就是最后1个十进制数字），代表了主机。其实单单从ip地址是看不出来哪些机器是一个子网的，因为从10进制是判断不出来的。需要通过ip地址的二进制来判断，结合一个概念来判断，叫做<strong>子网掩码</strong>。ip地址和自己的子网掩码进行二进制的与运算，与运算之后，比较一下代表网络的那部分。</p><p>有了网络层的ip地址之后，两台在子网内的电脑终于可以通过广播+mac地址判断来传输数据包进行通信了。</p><p>但是如果发现要接受数据包的计算机不在子网内，那么就不能通过广播来发送数据包，需要通过<strong>路由</strong>来发送数据包。路由器，其实就是配置了多个网卡的一个专用设备，可以通过不同的网卡接入不同的网络。</p><p>网关其实是就是路由器的一种，运作在网络层，大家可以就把路由器上的ip地址认为是网关，路由器上每个网卡都有mac地址和对应的ip地址。路由器虽然有mac地址，但是不能通过mac地址寻址的，必须通过ip地址寻址，所以<u>路由器其实是工作在网络层</u>的设备。</p><p><u>网络交换机是工作在数据链路层</u>的，路由器是工作在网路层的。<u>网络交换机是通过mac地址来寻址和传输数据包的</u>；但是<u>路由器是通过ip地址寻址和传输数据包的</u>。<u>网络交换机主要用在局域网的通信</u>，一般你架设一个局域网，里面的电脑通信是通过数据链路层发送数据包，通过mac地址来广播的，广播的时候就是通过网络交换机这个设备来把数据广播到局域网内的其他机器上去的；路由器一般用来让你连入英特网。</p><p><strong>LAN</strong>：就是local area network，就是局域网；</p><p><strong>WAN</strong>：就是wide area network，就是广域网。</p><p><strong>WLAN</strong>：wireless local area network，就是无线局域网，也就是wifi，在局域网内，直接通过wifi无线联网。</p><p>一个子网内的机器之间通信，就是在数据包里写上对方的mac地址，然后交换机广播出去ok了；但是如果是跨子网的通信，就是写上对方的ip地址，然后先通过mac地址广播到路由器，让路由器再根据另外一个子网的ip地址转换为mac地址，通过另外一个子网的交换机广播过去。</p><ul><li><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4></li></ul><p>网络层，是基于ip协议，进行主机和主机间的寻址和通信的，然后<u>传输层，其实是建立某个主机的某个端口，到另外一个主机的某个端口的连接和通信</u>的。这个通信，就是通过<strong>socket</strong>来实现的，通过socket就可以基于tcp/ip协议完成刚才上面说的一系列的比如基于ip地址和mac地址转换和寻址啊，通过路由器通信啊之类的，而且会建立一个端口到另外一个端口的连接。</p><p><strong>udp</strong>和<strong>tcp</strong>都是传输层的协议，作用就是在数据包里加入端口号，可以通过端口号进行点对点的通信了。udp协议是不可靠的，发出去人家收到没有就不知道了；tcp协议是可靠的，要求三次握手，而且要求人家接收到数据必须回复你。</p><ul><li><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4></li></ul><p>通过传输层的tcp协议可以传输数据，但是人家收到数据之后，怎么来解释？比如说收到个邮件你怎么处理？收到个网页你怎么处理？类似这个意思，所以针对各种不同的应用，邮件、网页之类的，都是定义不同的应用层协议的。这个应用层，我们就假设综合了会话层、表示层和应用层了，3层合成1层。</p><p>比如最常见的应用层的协议就是http协议，进行网络通信。</p><p>DNS地址是啥呢？Domain Name System。因为我们一般定位是通过ip地址+mac地址+端口号来定位一个通信目标的，但是如果在浏览器上输入一个<code>www.baidu.com</code>发给DNS服务器，然后DNS服务器告诉你<code>www.baidu.com</code>对应的ip地址的。</p><p><img src="https://cdn.jsdelivr.net/gh/developing-man/ImgHosting/TIMON-PIC/01_%E4%BB%8E%E5%BA%95%E5%90%91%E4%B8%8A%E5%AD%A6%E4%B9%A0TCP_IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/developing-man/ImgHosting/TIMON-PIC/01_%E4%BB%8E%E5%BA%95%E5%90%91%E4%B8%8A%E5%AD%A6%E4%B9%A0TCP_IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="网络传输过程解析"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;四层模型和七层模型&quot;&gt;&lt;a href=&quot;#四层模型和七层模型&quot; class=&quot;headerlink&quot; title=&quot;四层模型和七层模型&quot;&gt;&lt;/a&gt;&lt;strong&gt;四层模型和七层模型&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;OSI七层模型，就是搞一个标准的网络模型出来，大家</summary>
      
    
    
    
    <category term="网络" scheme="https://devloperhu.gitee.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之备忘录模式</title>
    <link href="https://devloperhu.gitee.io/posts/15653.html"/>
    <id>https://devloperhu.gitee.io/posts/15653.html</id>
    <published>2021-04-12T14:05:41.000Z</published>
    <updated>2021-12-16T15:12:19.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><pre><code>public static void main(String[] args) &#123;    Originator originator = new Originator();        // 准备好了中间数据    originator.prepare();    // 将中间数据保存到备忘录中去    Memento memento = originator.createMemento();    // 将备忘录保存到备忘录管理器中去    Caretaker caretaker = new Caretaker();    caretaker.saveMemento(memento);    // 基于中间数据执行了A方法，但是此时中间数据已经改变了    originator.executeA();    // 从备忘录管理器中获取备忘录    memento = caretaker.retrieveMemento();    // 将备忘录中保存好的中间数据重新设置到原发器中去，就将中间数据恢复成了之前备忘的状态    originator.setMemento(memento);    // 接着再次执行方法B    originator.executeB();        // 面临的场景    // 你的系统会生产出来一份中间数据，这份中间数据要么是没法一直在内存里保留，要么是可能会被修改    // 所以逼得你迫不得已，必须得通过备忘录的方式，将中间数据暂存一份儿    // 在一堆操作过后，可能之前内存中的中间数据都弄丢了，也可能中间数据被人篡改了    // 接下来，你需要从备忘录中恢复我们的中间数据    // 基于恢复后的中间数据，再次执行后面的操作&#125;public interface Memento &#123;    &#125;public static class Originator &#123;        private String state;        public void prepare() &#123;        this.state = &quot;中间数据&quot;;    &#125;        public void executeA() &#123;        System.out.println(&quot;基于中间数据【&quot; + state +&quot;】执行了A方法的逻辑&quot;);        // 将state所代表的中间数据做出了修改        state += &quot;，A方法的结果数据&quot;;    &#125;        public void executeB() &#123;        System.out.println(&quot;基于中间数据【&quot; + state +&quot;】执行了B方法的逻辑&quot;);        state += &quot;，B方法的结果数据&quot;;    &#125;        public Memento createMemento() &#123;        return new MementoImpl(state);    &#125;        public void setMemento(Memento memento) &#123;        MementoImpl mementoImpl = (MementoImpl)memento;        this.state = mementoImpl.getState();    &#125;        private static class MementoImpl implements Memento &#123;                private String state;                public MementoImpl(String state) &#123;            this.state = state;        &#125;                public String getState() &#123;            return state;        &#125;            &#125;    &#125;public static class Caretaker &#123;        private Memento memento;        public void saveMemento(Memento memento) &#123;        this.memento = memento;    &#125;        public Memento retrieveMemento() &#123;        return this.memento;    &#125;    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;备忘录模式&quot;&gt;&lt;a href=&quot;#备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式&quot;&gt;&lt;/a&gt;备忘录模式&lt;/h2&gt;&lt;p&gt;备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之访问者模式</title>
    <link href="https://devloperhu.gitee.io/posts/1606.html"/>
    <id>https://devloperhu.gitee.io/posts/1606.html</id>
    <published>2021-04-11T11:58:21.000Z</published>
    <updated>2021-12-16T15:12:19.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Department leafDept1 = <span class="keyword">new</span> Department(<span class="string">&quot;叶子部门1&quot;</span>); </span><br><span class="line">Department leafDept2 = <span class="keyword">new</span> Department(<span class="string">&quot;叶子部门2&quot;</span>);</span><br><span class="line">Department leafDept3 = <span class="keyword">new</span> Department(<span class="string">&quot;叶子部门3&quot;</span>); </span><br><span class="line"></span><br><span class="line">Department subDept1 = <span class="keyword">new</span> Department(<span class="string">&quot;子部门1&quot;</span>);</span><br><span class="line">subDept1.getChildren().add(leafDept1);</span><br><span class="line">subDept1.getChildren().add(leafDept2);</span><br><span class="line"></span><br><span class="line">Department subDept2 = <span class="keyword">new</span> Department(<span class="string">&quot;子部门2&quot;</span>); </span><br><span class="line">subDept2.getChildren().add(leafDept3);</span><br><span class="line"></span><br><span class="line">Department parentDept = <span class="keyword">new</span> Department(<span class="string">&quot;父部门&quot;</span>);</span><br><span class="line">parentDept.getChildren().add(subDept1);</span><br><span class="line">parentDept.getChildren().add(subDept2);</span><br><span class="line"></span><br><span class="line">Visitor removeVisitor = <span class="keyword">new</span> RemoveVisitor();</span><br><span class="line">parentDept.accept(removeVisitor);</span><br><span class="line"></span><br><span class="line">Visitor updateStatusVisitor = <span class="keyword">new</span> UpdateStatusVisitor(<span class="string">&quot;禁用&quot;</span>);  </span><br><span class="line">parentDept.accept(updateStatusVisitor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者模式，一般来说，就是跟组合模式结合起来使用的</span></span><br><span class="line"><span class="comment">// 组合模式代表了一种复杂的对象的类型</span></span><br><span class="line"><span class="comment">// 如果你后面要给树形的数据结构增加个什么功能，修改代码可能会比较麻烦</span></span><br><span class="line"><span class="comment">// 但是如果采用访问者模式来做，你可以在任何时候给树形的数据结构增加任何的功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> List&lt;Department&gt; children = <span class="keyword">new</span> ArrayList&lt;Department&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Department&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(List&lt;Department&gt; children)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.children = children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Department dept)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Department dept)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dept.getChildren().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(Department child : dept.getChildren()) &#123;  </span><br><span class="line">child.accept(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;删除部门【&quot;</span> + dept.getName() + <span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateStatusVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Department dept)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dept.getChildren().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(Department child : dept.getChildren()) &#123;  </span><br><span class="line">child.accept(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;将部门【&quot;</span> + dept.getName() + <span class="string">&quot;】的状态修改为：&quot;</span> + status);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UpdateStatusVisitor</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.status = status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;访问者模式&quot;&gt;&lt;a href=&quot;#访问者模式&quot; class=&quot;headerlink&quot; title=&quot;访问者模式&quot;&gt;&lt;/a&gt;访问者模式&lt;/h2&gt;&lt;p&gt;在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之桥接模式</title>
    <link href="https://devloperhu.gitee.io/posts/60984.html"/>
    <id>https://devloperhu.gitee.io/posts/60984.html</id>
    <published>2021-04-10T12:24:03.000Z</published>
    <updated>2021-12-16T15:12:19.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Implementor implementor = <span class="keyword">new</span> ConcreteImplementor();</span><br><span class="line">Abstraction abstraction = <span class="keyword">new</span> RefinedAbstraction(implementor);</span><br><span class="line">abstraction.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// implementor可以认为是一个代码组件，包含了一个接口和一个实现类</span></span><br><span class="line"><span class="comment">// abstraction可以认为是一个代码组件，包含了一个抽象类和一个子类</span></span><br><span class="line"><span class="comment">// abstraction要调用implementor的接口</span></span><br><span class="line"><span class="comment">// 在abstraction中包含了一个implementor的接口</span></span><br><span class="line"><span class="comment">// 在abstraction调用implementor的时候，实际上是面向implementor接口去编程和调用的</span></span><br><span class="line"><span class="comment">// 只不过我们会将implementor的实现类实例传入abstraction中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// abstraction调用implementor就是基于一个桥去调用的</span></span><br><span class="line"><span class="comment">// 不是说abstraction直接仅仅面向implementor实现类去编程的，面向implementor接口去编程的</span></span><br><span class="line"><span class="comment">// 所以abstraction和implementor两个代码组件之间的桥，就是implementor接口</span></span><br><span class="line"><span class="comment">// 这个一个代码组件面向另外一个代码组件的接口来编程，就是将那个接口作为一个桥</span></span><br><span class="line"><span class="comment">// 使用了桥接的设计模式来编程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 桥接模式，都不需要运用，java之中，无处不桥接</span></span><br><span class="line"><span class="comment">// 几乎所有的编程，都是面向接口去编程的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行了功能逻辑&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Implementor implementor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(implementor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">implementor.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; title=&quot;桥接模式&quot;&gt;&lt;/a&gt;桥接模式&lt;/h2&gt;&lt;p&gt;桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之责任链模式</title>
    <link href="https://devloperhu.gitee.io/posts/3292.html"/>
    <id>https://devloperhu.gitee.io/posts/3292.html</id>
    <published>2021-04-09T12:13:09.000Z</published>
    <updated>2021-12-16T15:12:19.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 业务流程1</span></span><br><span class="line">Handler thirdHandler = <span class="keyword">new</span> Handler3(<span class="keyword">null</span>);</span><br><span class="line">Handler secondHandler = <span class="keyword">new</span> Handler2(thirdHandler);</span><br><span class="line">Handler firstHandler = <span class="keyword">new</span> Handler1(secondHandler);</span><br><span class="line">firstHandler.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务流程2</span></span><br><span class="line">thirdHandler = <span class="keyword">new</span> Handler3(<span class="keyword">null</span>);</span><br><span class="line">secondHandler = <span class="keyword">new</span> Handler1(thirdHandler);</span><br><span class="line">firstHandler = <span class="keyword">new</span> Handler2(secondHandler);</span><br><span class="line">firstHandler.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 责任链的思想</span></span><br><span class="line"><span class="comment">// 1：将一个业务流程中的多个步骤拆分开来，每个步骤封装到一个handler处理器中去</span></span><br><span class="line"><span class="comment">// 2：支持业务流程基于handler动态组装，不同的业务流程 -&gt; handler代表的代码组件可以复用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好处1：将这个代码封装到一个handler中，后面如果要对某个步骤的代码逻辑调整，修改一个handler即可</span></span><br><span class="line"><span class="comment">// 好处2：如果业务流程要修改，那么不需要拷贝大量的代码，只要基于handler动态组装业务流程即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面向的场景</span></span><br><span class="line"><span class="comment">// 就是有多个业务流程，这些业务流程之间有相同的代码逻辑和步骤</span></span><br><span class="line"><span class="comment">// 可以用责任链模式来实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.successor = successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler1</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(successor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行功能1&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span>(successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">successor.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler2</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(successor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行功能2&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span>(successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">successor.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler3</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler3</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(successor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行功能3&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span>(successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">successor.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;责任链模式&quot;&gt;&lt;a href=&quot;#责任链模式&quot; class=&quot;headerlink&quot; title=&quot;责任链模式&quot;&gt;&lt;/a&gt;责任链模式&lt;/h2&gt;&lt;p&gt;顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之享元模式</title>
    <link href="https://devloperhu.gitee.io/posts/47555.html"/>
    <id>https://devloperhu.gitee.io/posts/47555.html</id>
    <published>2021-04-08T11:45:39.000Z</published>
    <updated>2022-03-06T08:16:48.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><p>享元模式的常见使用场景，其实就是jvm内缓存实现，如果我们不想引入ehcache之类缓存框架，就想简单一点，通过自己实现的一个map来缓存对应的一些数据，比如说每个权限的数据，或者每个员工的数据，在内存里自己维护一个缓存工厂，就是基于享元模式的思想来实现的。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Flyweight flyweight1 = FlyweightFactory.get(<span class="string">&quot;对象1&quot;</span>); </span><br><span class="line">flyweight1.execute();</span><br><span class="line"></span><br><span class="line">Flyweight flyweight2 = FlyweightFactory.get(<span class="string">&quot;对象1&quot;</span>); </span><br><span class="line">flyweight2.execute();</span><br><span class="line"></span><br><span class="line">System.out.println(flyweight1 == flyweight2);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元</span></span><br><span class="line"><span class="comment">// 享受，元数据</span></span><br><span class="line"><span class="comment">// 同一个数据，我就认为是一个元数据，整个系统里这个数据就一份，缓存起来</span></span><br><span class="line"><span class="comment">// 整个系统对这个数据，全部享受他一个对象实例即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接既有内存来缓存一块数据，用享元模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">&quot;执行功能逻辑&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Flyweight&gt; cachePool = <span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title">get</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">Flyweight flyweight = cachePool.get(name);</span><br><span class="line"><span class="keyword">if</span>(flyweight == <span class="keyword">null</span>) &#123;</span><br><span class="line">flyweight = <span class="keyword">new</span> ConcreteFlyweight(name);</span><br><span class="line">cachePool.put(name, flyweight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flyweight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a><strong>代码实战</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanCopier工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhonghuashishan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopierUtils</span> </span>&#123;  </span><br><span class="line">       </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanCopier缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, BeanCopier&gt; beanCopierCacheMap = <span class="keyword">new</span> HashMap&lt;String, BeanCopier&gt;();  </span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将source对象的属性拷贝到target对象中去</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source source对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target target对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target)</span></span>&#123;  </span><br><span class="line">        String cacheKey = source.getClass().toString() + </span><br><span class="line">        target.getClass().toString();  </span><br><span class="line">        </span><br><span class="line">        BeanCopier beanCopier = <span class="keyword">null</span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线程1和线程2，同时过来了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!beanCopierCacheMap.containsKey(cacheKey)) &#123;  </span><br><span class="line">        <span class="comment">// 两个线程都卡这儿了</span></span><br><span class="line">        <span class="comment">// 但是此时线程1先获取到了锁，线程2就等着</span></span><br><span class="line">        <span class="keyword">synchronized</span>(BeanCopierUtils.class) &#123;</span><br><span class="line">        <span class="comment">// 线程1进来之后，发现这里还是没有那个BeanCopier实例</span></span><br><span class="line">        <span class="comment">// 此时线程2，会发现缓存map中已经有了那个BeanCopier实例了，此时就不会进入if判断内的代码</span></span><br><span class="line">         <span class="keyword">if</span>(!beanCopierCacheMap.containsKey(cacheKey)) &#123; </span><br><span class="line">         <span class="comment">// 进入到这里会创建一个BeanCopier实例并且放在缓存map中</span></span><br><span class="line">         beanCopier = BeanCopier.create(source.getClass(), target.getClass(), <span class="keyword">false</span>);  </span><br><span class="line">         beanCopierCacheMap.put(cacheKey, beanCopier);  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         beanCopier = beanCopierCacheMap.get(cacheKey);   </span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            beanCopier = beanCopierCacheMap.get(cacheKey);   </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        beanCopier.copy(source, target, <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h2&gt;&lt;p&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="https://devloperhu.gitee.io/posts/56671.html"/>
    <id>https://devloperhu.gitee.io/posts/56671.html</id>
    <published>2021-04-07T14:03:22.000Z</published>
    <updated>2021-12-16T15:12:19.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> NewState());</span><br><span class="line">context.execute(<span class="number">1</span>); </span><br><span class="line">context.execute(<span class="number">2</span>); </span><br><span class="line">context.execute(<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 适合场景，数据有状态，状态就一定会流转，从状态1变成状态2</span></span><br><span class="line"><span class="comment">// 将不同的状态要执行的代码逻辑封装在不同的state类中</span></span><br><span class="line"><span class="comment">// 有一个context类，负责根据传入的参数，决定这份数据的状态流转到什么状态</span></span><br><span class="line"><span class="comment">// 同时负责执行那个新状态的代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行销售出库单新建状态的逻辑&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApprovingState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行销售出库单待审批状态的逻辑&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApprovedState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行销售出库单已审批状态的逻辑&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinishedState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行销售出库单已完成状态的逻辑&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.state = state;</span><br><span class="line"><span class="keyword">this</span>.state.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> stateType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(stateType == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.state = <span class="keyword">new</span> ApprovingState();</span><br><span class="line"><span class="keyword">this</span>.state.execute();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(stateType == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.state = <span class="keyword">new</span> ApprovedState();</span><br><span class="line"><span class="keyword">this</span>.state.execute();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(stateType == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.state = <span class="keyword">new</span> FinishedState();</span><br><span class="line"><span class="keyword">this</span>.state.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;状态模式&quot;&gt;&lt;a href=&quot;#状态模式&quot; class=&quot;headerlink&quot; title=&quot;状态模式&quot;&gt;&lt;/a&gt;状态模式&lt;/h2&gt;&lt;p&gt;在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="https://devloperhu.gitee.io/posts/41543.html"/>
    <id>https://devloperhu.gitee.io/posts/41543.html</id>
    <published>2021-04-06T13:17:48.000Z</published>
    <updated>2021-12-15T15:40:44.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><p>策略模式，将会成为最最高频使用的一种设计模式，他的常见应用场景，就是替换掉那一大坨复杂难懂的if else if else。对于那种过于复杂的选择判断逻辑，完全可以将选择哪种策略的过程放到工厂里去。工厂，可以是简单工厂，也可以是工厂方法，也可以是抽象工厂。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> discountStyle = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">DiscountCalculateStrategy strategy = DiscountCalculateStrategryFactory</span><br><span class="line">.getDiscountCalculateStrategy(discountStyle);</span><br><span class="line"></span><br><span class="line">Context context = <span class="keyword">new</span> Context();</span><br><span class="line">context.setStrategy(strategy); </span><br><span class="line">context.calculate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要点1：必须将if else的代码，封装到不同的策略类中</span></span><br><span class="line"><span class="comment">// 要点2：将选择哪种策略的逻辑给放到一个工厂类中去，选择策略的代码务必很简洁</span></span><br><span class="line"><span class="comment">// 要点3：context可有可无，具体是看你的策略执行这块如果就一行代码调用，不需要context</span></span><br><span class="line"><span class="comment">// 如果context中的策略执行逻辑较为复杂一点，context来封装策略类的执行逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountCalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCalculateStrategyA</span> <span class="keyword">implements</span> <span class="title">DiscountCalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行优惠计价方式1的复杂业务逻辑&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCalculateStrategyB</span> <span class="keyword">implements</span> <span class="title">DiscountCalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行优惠计价方式2的复杂业务逻辑&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCalculateStrategyC</span> <span class="keyword">implements</span> <span class="title">DiscountCalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行优惠计价方式3的复杂业务逻辑&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCalculateStrategyDefault</span> <span class="keyword">implements</span> <span class="title">DiscountCalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行默认的优惠计价方式的复杂业务逻辑&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountCalculateStrategryFactory</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiscountCalculateStrategy <span class="title">getDiscountCalculateStrategy</span><span class="params">(<span class="keyword">int</span> discountStyle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(discountStyle == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DiscountCalculateStrategyA();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(discountStyle == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DiscountCalculateStrategyB();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(discountStyle == <span class="number">3</span>) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DiscountCalculateStrategyC();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DiscountCalculateStrategyDefault();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DiscountCalculateStrategy strategy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscountCalculateStrategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(DiscountCalculateStrategy strategy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">strategy.calculate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;p&gt;在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合模式</title>
    <link href="https://devloperhu.gitee.io/posts/59529.html"/>
    <id>https://devloperhu.gitee.io/posts/59529.html</id>
    <published>2021-04-05T12:33:29.000Z</published>
    <updated>2021-12-15T15:16:49.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Department leafDept1 = <span class="keyword">new</span> Department(<span class="string">&quot;叶子部门1&quot;</span>); </span><br><span class="line">Department leafDept2 = <span class="keyword">new</span> Department(<span class="string">&quot;叶子部门2&quot;</span>);</span><br><span class="line">Department leafDept3 = <span class="keyword">new</span> Department(<span class="string">&quot;叶子部门3&quot;</span>); </span><br><span class="line"></span><br><span class="line">Department subDept1 = <span class="keyword">new</span> Department(<span class="string">&quot;子部门1&quot;</span>);</span><br><span class="line">subDept1.getChildren().add(leafDept1);</span><br><span class="line">subDept1.getChildren().add(leafDept2);</span><br><span class="line"></span><br><span class="line">Department subDept2 = <span class="keyword">new</span> Department(<span class="string">&quot;子部门2&quot;</span>); </span><br><span class="line">subDept2.getChildren().add(leafDept3);</span><br><span class="line"></span><br><span class="line">Department parentDept = <span class="keyword">new</span> Department(<span class="string">&quot;父部门&quot;</span>);</span><br><span class="line">parentDept.getChildren().add(subDept1);</span><br><span class="line">parentDept.getChildren().add(subDept2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题：对层级数据的操作，很恶心，很不方便，需要手工编写大量的代码</span></span><br><span class="line"><span class="comment">// for(Department subDept : parentDept.getChildren()) &#123;</span></span><br><span class="line"><span class="comment">//   if(subDept.getChildren().size() &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//   for(Department leafDept : subDept.getChildren()) &#123;</span></span><br><span class="line"><span class="comment">//   leafDept.remove();</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//     subDept.remove();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// parentDept.remove();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对调用者来说，一步解决</span></span><br><span class="line">parentDept.remove();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> List&lt;Department&gt; children = <span class="keyword">new</span> ArrayList&lt;Department&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Department&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(List&lt;Department&gt; children)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.children = children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public void remove() &#123;</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;删除部门【&quot; + name + &quot;】&quot;);  </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用组合模式，自己完成对应的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(children.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(Department child : children) &#123;</span><br><span class="line">child.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;删除部门【&quot;</span> + name + <span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;headerlink&quot; title=&quot;组合模式&quot;&gt;&lt;/a&gt;组合模式&lt;/h2&gt;&lt;p&gt;组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之命令模式</title>
    <link href="https://devloperhu.gitee.io/posts/7817.html"/>
    <id>https://devloperhu.gitee.io/posts/7817.html</id>
    <published>2021-04-04T15:15:56.000Z</published>
    <updated>2021-12-15T15:17:46.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Command commandA = <span class="keyword">new</span> CommandA();</span><br><span class="line">Command commandB = <span class="keyword">new</span> CommandB();</span><br><span class="line"></span><br><span class="line">Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line"></span><br><span class="line">invoker.setCommand(commandA); </span><br><span class="line">invoker.execute();</span><br><span class="line"></span><br><span class="line">invoker.setCommand(commandB);</span><br><span class="line">invoker.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="comment">// 有两种请求要发送过来执行</span></span><br><span class="line"><span class="comment">// 一种请求是读请求，一种请求是写请求，不同请求要执行的功能逻辑是不一样的</span></span><br><span class="line"><span class="comment">// 此时就非常适合用这个命令模式</span></span><br><span class="line"><span class="comment">// 将读请求的功能逻辑封装到ReadCommand里面去，将写请求的功能逻辑封装到WriteCommand里面去</span></span><br><span class="line"><span class="comment">// 然后设置一个通用的一个命令执行的类</span></span><br><span class="line"><span class="comment">// 读请求来了，就封装ReadCommand，交给同一个命令执行类来执行即可</span></span><br><span class="line"><span class="comment">// 写请求来了，就封装WriteCommand，交给同一个命令感知性类来执行即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandA</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;命令A的功能逻辑&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandB</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;命令B的功能逻辑&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Command <span class="title">getCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.command = command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;一些别的逻辑A&quot;</span>);</span><br><span class="line">command.execute();</span><br><span class="line">System.out.println(<span class="string">&quot;一些别的逻辑B&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerlink&quot; title=&quot;命令模式&quot;&gt;&lt;/a&gt;命令模式&lt;/h2&gt;&lt;p&gt;命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="https://devloperhu.gitee.io/posts/64715.html"/>
    <id>https://devloperhu.gitee.io/posts/64715.html</id>
    <published>2021-04-03T14:45:56.000Z</published>
    <updated>2021-12-13T14:26:28.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AppData data = <span class="keyword">new</span> ProxyRedisData(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次数据将从MySQL加载</span></span><br><span class="line">data.getData();</span><br><span class="line">System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line"><span class="comment">// 第二次则走Redis缓存</span></span><br><span class="line">data.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppData</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlData</span> <span class="keyword">implements</span> <span class="title">AppData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String dataTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MysqlData</span><span class="params">(String dataTable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.dataTable = dataTable;</span><br><span class="line">loadFromMysql(dataTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show cache data &quot;</span> + dataTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromMysql</span><span class="params">(String dataTable)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Loading data from MySQL：&quot;</span> + dataTable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyRedisData</span> <span class="keyword">implements</span> <span class="title">AppData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MysqlData cacheData;</span><br><span class="line"><span class="keyword">private</span> String table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyRedisData</span><span class="params">(String table)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.table = table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cacheData == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;redis无此缓存数据，请先查MySQL&quot;</span>);</span><br><span class="line">cacheData = <span class="keyword">new</span> MysqlData(table);</span><br><span class="line">&#125;</span><br><span class="line">cacheData.getData();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis无此缓存数据，请先查MySQL</span><br><span class="line">Loading data from MySQL：student</span><br><span class="line">show cache data student</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">show cache data student</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;p&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。&lt;/p&gt;
&lt;p&gt;在代</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="https://devloperhu.gitee.io/posts/63625.html"/>
    <id>https://devloperhu.gitee.io/posts/63625.html</id>
    <published>2021-04-03T11:55:23.000Z</published>
    <updated>2021-12-15T15:32:10.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>比如我们有一个目标对象，一旦这个目标对象的状态改变了，然后的话就去通知相关的对象，我的状态改变了，数据也变化了</li><li>前端开发，js脚本，要对界面上的各种视图组件，表格点击事件，按钮点击，添加监听器，一旦某种事件发生，就会执行监听器中的方法</li><li>系统A发送了一条消息到内存队列，系统B获取了消息开始执行操作，但是系统A需要知道系统B的一个执行的结果如何，此时怎么办？系统A需要注册一个观察者到系统B上去，系统B执行完了之后，将执行的结果，反过来通知给系统，我们就可以基于观察者模式去做</li></ul><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Subject subject = <span class="keyword">new</span> Subject(<span class="number">0</span>); </span><br><span class="line">    Observer observer = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">    subject.addObserver(observer); </span><br><span class="line"></span><br><span class="line">    subject.setState(<span class="number">1</span>);</span><br><span class="line">    subject.setState(<span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(Integer state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(Integer state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里状态就改变了</span></span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 通知关联的一些观察者，说我的状态变化了</span></span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="comment">//this.notifyObservers(state);  // 推模式：告知并告知结果</span></span><br><span class="line">        <span class="keyword">this</span>.notifyObservers();    <span class="comment">// 拉模式：告知但结果自取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Integer state = (Integer) arg;</span></span><br><span class="line">Subject subject = (Subject) o;</span><br><span class="line">Integer state = subject.getState();</span><br><span class="line">System.out.println(<span class="string">&quot;目标对象的状态变化成：&quot;</span> + state);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;p&gt;当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之中介者模式</title>
    <link href="https://devloperhu.gitee.io/posts/15884.html"/>
    <id>https://devloperhu.gitee.io/posts/15884.html</id>
    <published>2021-04-02T12:13:44.000Z</published>
    <updated>2021-12-13T14:26:28.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p><p>这个模式，担心的就是系统中各个子系统之前互相之间调用，乱成一团。所以就将系统之间互相调用的逻辑给放到一个所谓的中介者里面去。每个系统如果要通知别的系统干个什么事儿，直接就是调用中介者，中介者负责去调用别的系统。</p><p>在实际的企业开发中，不是这么玩儿的，很少有见到说封装一个所谓的中介者，去让各个模块之间解耦，思考这个模式的本质，让各个模块之间解耦合</p><p>最最常见的一个方式，就是系统与系统之间，不是走直接的接口调用，而是基于MQ来解耦。如果模块A要调用模块B和模块C，模块A发送一条消息到MQ里面去，模块B和模块C去消费这条消息，读到消息之后，知道模块A要调用自己，所以就执行对应的逻辑即可。常见于系统与系统之间的调用，可以基于MQ消息，异步执行的方式来调用，不需要同步调用和执行。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>没有中介者的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ModuleA moduleA = <span class="keyword">new</span> ModuleA();</span><br><span class="line">ModuleB moduleB = <span class="keyword">new</span> ModuleB();</span><br><span class="line">ModuleC moduleC = <span class="keyword">new</span> ModuleC();</span><br><span class="line">moduleA.execute();  </span><br><span class="line">moduleB.execute();  </span><br><span class="line">moduleC.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块之间有非常复杂的互相之间的跟蜘蛛网一样的调用</span></span><br><span class="line"><span class="comment">// 问题，每个模块都要去care很多其他的模块，互相之间耦合很严重</span></span><br><span class="line"><span class="comment">// 后面在修改代码的时候，代码不好改，模块B一旦修改了自己的代码，可能会影响模块A和模块C</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ModuleB moduleB = <span class="keyword">new</span> ModuleB();</span><br><span class="line">ModuleC moduleC = <span class="keyword">new</span> ModuleC();</span><br><span class="line">moduleB.execute(<span class="string">&quot;模块A&quot;</span>);  </span><br><span class="line">moduleC.execute(<span class="string">&quot;模块A&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String invoker)</span> </span>&#123;</span><br><span class="line">System.out.println(invoker + <span class="string">&quot;在调用模块A的功能&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ModuleA moduleA = <span class="keyword">new</span> ModuleA();</span><br><span class="line">ModuleC moduleC = <span class="keyword">new</span> ModuleC();</span><br><span class="line">moduleA.execute(<span class="string">&quot;模块B&quot;</span>);  </span><br><span class="line">moduleC.execute(<span class="string">&quot;模块B&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String invoker)</span> </span>&#123;</span><br><span class="line">System.out.println(invoker + <span class="string">&quot;在调用模块B的功能&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ModuleA moduleA = <span class="keyword">new</span> ModuleA();</span><br><span class="line">ModuleB moduleB = <span class="keyword">new</span> ModuleB();</span><br><span class="line">moduleA.execute(<span class="string">&quot;模块C&quot;</span>);  </span><br><span class="line">moduleB.execute(<span class="string">&quot;模块C&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String invoker)</span> </span>&#123;</span><br><span class="line">System.out.println(invoker + <span class="string">&quot;在调用模块C的功能&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入中介者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Mediator mediator = <span class="keyword">new</span> Mediator();</span><br><span class="line"></span><br><span class="line">ModuleA moduleA = <span class="keyword">new</span> ModuleA(mediator);</span><br><span class="line">ModuleB moduleB = <span class="keyword">new</span> ModuleB(mediator);</span><br><span class="line">ModuleC moduleC = <span class="keyword">new</span> ModuleC(mediator);</span><br><span class="line"></span><br><span class="line">moduleA.execute();  </span><br><span class="line">moduleB.execute();  </span><br><span class="line">moduleC.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好处在哪儿</span></span><br><span class="line"><span class="comment">// moduleA，只要知道一个中介者就可以了，具体跟其他模块的交互都封装在中介者里面了</span></span><br><span class="line"><span class="comment">// moduleB，同上</span></span><br><span class="line"><span class="comment">// moduleC，同上</span></span><br><span class="line"><span class="comment">// moduleA、B、C之间不再有任何的耦合，不再有复杂的交互关系，互相之间修改不会对对方产生什么影响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ModuleA moduleA;</span><br><span class="line"><span class="keyword">private</span> ModuleB moduleB;</span><br><span class="line"><span class="keyword">private</span> ModuleC moduleC;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModuleA <span class="title">getModuleA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> moduleA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModuleA</span><span class="params">(ModuleA moduleA)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.moduleA = moduleA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModuleB <span class="title">getModuleB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> moduleB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModuleB</span><span class="params">(ModuleB moduleB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.moduleB = moduleB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModuleC <span class="title">getModuleC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> moduleC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModuleC</span><span class="params">(ModuleC moduleC)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.moduleC = moduleC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moduleAInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">moduleB.execute(<span class="string">&quot;模块A通知中介者&quot;</span>);  </span><br><span class="line">moduleC.execute(<span class="string">&quot;模块A通知中介者&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moduleBInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">moduleA.execute(<span class="string">&quot;模块B通知中介者&quot;</span>);  </span><br><span class="line">moduleC.execute(<span class="string">&quot;模块B通知中介者&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moduleCInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">moduleA.execute(<span class="string">&quot;模块C通知中介者&quot;</span>);  </span><br><span class="line">moduleB.execute(<span class="string">&quot;模块C通知中介者&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ModuleA</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mediator = mediator;</span><br><span class="line"><span class="keyword">this</span>.mediator.setModuleA(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mediator.moduleAInvoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String invoker)</span> </span>&#123;</span><br><span class="line">System.out.println(invoker + <span class="string">&quot;在调用模块A的功能&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ModuleB</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mediator = mediator;</span><br><span class="line"><span class="keyword">this</span>.mediator.setModuleB(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mediator.moduleBInvoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String invoker)</span> </span>&#123;</span><br><span class="line">System.out.println(invoker + <span class="string">&quot;在调用模块B的功能&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ModuleC</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mediator = mediator;</span><br><span class="line"><span class="keyword">this</span>.mediator.setModuleC(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mediator.moduleCInvoke(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String invoker)</span> </span>&#123;</span><br><span class="line">System.out.println(invoker + <span class="string">&quot;在调用模块C的功能&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;中介者模式&quot;&gt;&lt;a href=&quot;#中介者模式&quot; class=&quot;headerlink&quot; title=&quot;中介者模式&quot;&gt;&lt;/a&gt;中介者模式&lt;/h2&gt;&lt;p&gt;中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之原型模式</title>
    <link href="https://devloperhu.gitee.io/posts/8028.html"/>
    <id>https://devloperhu.gitee.io/posts/8028.html</id>
    <published>2021-03-30T13:12:22.000Z</published>
    <updated>2022-03-06T09:44:20.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><p><strong>关键代码：</strong> 实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>不用克隆的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 手头有这么一个对象，需要进行拷贝</span></span><br><span class="line">Product product = <span class="keyword">new</span> Product(<span class="string">&quot;测试产品&quot;</span>, <span class="keyword">new</span> Component(<span class="string">&quot;测试组件&quot;</span>));  </span><br><span class="line"><span class="comment">// 手动来拷贝</span></span><br><span class="line">Product copyProduct = <span class="keyword">new</span> Product(product.getName(), product.getComponent());</span><br><span class="line">System.out.println(copyProduct);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题是什么？</span></span><br><span class="line"><span class="comment">// 代码的拷贝逻辑，是每个要拷贝的调用方自己来实现的</span></span><br><span class="line"><span class="comment">// 相同的拷贝逻辑会分散在很多不同的地方，如果拷贝逻辑改变了，多个调用的地方都要修改代码</span></span><br><span class="line"><span class="comment">// 可维护性、可扩展性，很差</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Component [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String name, Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">getComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Product [name=&quot;</span> + name + <span class="string">&quot;, component=&quot;</span> + component + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用克隆后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Product product = <span class="keyword">new</span> Product(<span class="string">&quot;测试产品&quot;</span>, <span class="keyword">new</span> Component(<span class="string">&quot;测试组件&quot;</span>));  </span><br><span class="line">Product copyProduct = (Product) product.clone();</span><br><span class="line">System.out.println(copyProduct); </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型模式，就是在要拷贝的类里实现一个clone()方法，自己拷贝自己</span></span><br><span class="line"><span class="comment">// 拷贝的时候，就两个概念，浅拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 很多地方要克隆这个对象，不要自己维护克隆的逻辑，即使克隆逻辑修改了，只要在clone()方法里面修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Component [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝在其内部组件也需要逐级实现clone()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Component(getName()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String name, Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Component <span class="title">getComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Product [name=&quot;</span> + name + <span class="string">&quot;, component=&quot;</span> + component + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="comment">// 浅拷贝，就是我们现在的一个实现</span></span><br><span class="line"><span class="comment">// 就是仅仅简单的对当前所有的变量进行一个拷贝</span></span><br><span class="line">        <span class="comment">// return new Product(getName(), getComponent());</span></span><br><span class="line">        <span class="comment">// 深拷贝，递归对自己引用的对象也进行拷贝</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Product(getName(), (Component)getComponent().clone());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a><strong>代码实战</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础POJO类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhonghuashishan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅度克隆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">T target = clazz.newInstance();</span><br><span class="line"><span class="keyword">return</span> clone(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅度克隆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">BeanCopierUtils.copyProperties(<span class="keyword">this</span>, target);  </span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度克隆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(Class&lt;T&gt; clazz, Integer cloneDirection)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 先完成基本字段的浅克隆</span></span><br><span class="line">T target = clazz.newInstance();</span><br><span class="line">BeanCopierUtils.copyProperties(<span class="keyword">this</span>, target);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成所有List类型的深度克隆</span></span><br><span class="line"><span class="comment">// CategoryDTO</span></span><br><span class="line">Class&lt;?&gt; thisClazz = <span class="keyword">this</span>.getClass(); </span><br><span class="line"></span><br><span class="line">Field[] fields = thisClazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果判断某个字段是List类型的</span></span><br><span class="line"><span class="comment">// field = private List&lt;Relation&gt; relations; </span></span><br><span class="line"><span class="keyword">if</span>(field.getType() != List.class) &#123; </span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// field.getType() List 不是 List&lt;Relation&gt; </span></span><br><span class="line"><span class="comment">// List&lt;RelationDTO&gt;集合</span></span><br><span class="line">List&lt;?&gt; list = (List&lt;?&gt;) field.get(<span class="keyword">this</span>); </span><br><span class="line"><span class="keyword">if</span>(list == <span class="keyword">null</span> || list.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取List集合中的泛型类型</span></span><br><span class="line"><span class="comment">// RelationDTO</span></span><br><span class="line">Class&lt;?&gt; listGenericClazz = getListGenericType(field); </span><br><span class="line"><span class="comment">// 获取要克隆的目标类型</span></span><br><span class="line"><span class="comment">// 假设CloneDirection是反向，此时获取到的就是RelationVO</span></span><br><span class="line">        </span><br><span class="line">Class&lt;?&gt; cloneTargetClazz = getCloneTargetClazz(listGenericClazz, cloneDirection); </span><br><span class="line">        <span class="comment">// 将list集合克隆到目标list集合中去</span></span><br><span class="line">List clonedList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cloneList(list, clonedList, cloneTargetClazz, cloneDirection); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取设置克隆好的list的方法名称</span></span><br><span class="line"><span class="comment">// setRelations</span></span><br><span class="line">Method setFieldMethod = getSetCloneListFieldMethodName(field, clazz); </span><br><span class="line">setFieldMethod.invoke(target, clonedList); </span><br><span class="line"><span class="comment">// target是CategoryVO对象，此时就是调用CategoryVO的setRelations方法，</span></span><br><span class="line"><span class="comment">// 将克隆好的List&lt;CategoryVO&gt;给设置进去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h2&gt;&lt;p&gt;原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之构造器模式</title>
    <link href="https://devloperhu.gitee.io/posts/34453.html"/>
    <id>https://devloperhu.gitee.io/posts/34453.html</id>
    <published>2021-03-29T12:44:31.000Z</published>
    <updated>2021-12-12T15:55:11.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="普通代码"><a href="#普通代码" class="headerlink" title="普通代码"></a>普通代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构造这个复杂的product对象</span></span><br><span class="line">Product product = <span class="keyword">new</span> Product();</span><br><span class="line"><span class="comment">// 设置field1属性</span></span><br><span class="line">System.out.println(<span class="string">&quot;在设置field1之前进行复杂的校验逻辑&quot;</span>);  </span><br><span class="line">product.setField1(<span class="string">&quot;值1&quot;</span>);  </span><br><span class="line"><span class="comment">// 设置field2属性</span></span><br><span class="line">System.out.println(<span class="string">&quot;在设置field2之前进行复杂的数据格式转化逻辑&quot;</span>);  </span><br><span class="line">product.setField2(<span class="string">&quot;值2&quot;</span>);  </span><br><span class="line"><span class="comment">// 设置field3属性</span></span><br><span class="line">System.out.println(<span class="string">&quot;在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联&quot;</span>);</span><br><span class="line">product.setField3(<span class="string">&quot;值3&quot;</span>);  </span><br><span class="line">       <span class="comment">// 上面是简化的一个逻辑，实际上对于一些有几十个字段，甚至是上百个字段的复杂对象的构建</span></span><br><span class="line">       <span class="comment">// 上面那段代码会极度膨胀，非常复杂</span></span><br><span class="line">       <span class="comment">// 一个是说，大量代码堆积在一起，维护性非常差，可读性非常差，读不懂，没法改</span></span><br><span class="line">       <span class="comment">// 另外一个，这段逻辑，如果在多个地方都有使用的话，一旦这段逻辑出现了一些变化，那么可能就需要</span></span><br><span class="line">       <span class="comment">// 在多个地方修改</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> String field1;</span><br><span class="line">       <span class="keyword">private</span> String field2;</span><br><span class="line">       <span class="keyword">private</span> String field3;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getField1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> field1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField1</span><span class="params">(String field1)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.field1 = field1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getField2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> field2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField2</span><span class="params">(String field2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.field2 = field2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getField3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> field3;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField3</span><span class="params">(String field3)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.field3 = field3;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="用构造器设计模式"><a href="#用构造器设计模式" class="headerlink" title="用构造器设计模式"></a>用构造器设计模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Director director = <span class="keyword">new</span> Director(<span class="keyword">new</span> ConcreteBuilder());  </span><br><span class="line">Product product = director.build(<span class="string">&quot;值1&quot;</span>, <span class="string">&quot;值2&quot;</span>, <span class="string">&quot;值3&quot;</span>);  </span><br><span class="line">System.out.println(product);  </span><br><span class="line"><span class="comment">// 好处1：通过builder接口将复杂构建步骤拆分成了多个部分，代码逻辑清晰，维护性和扩展性都很好</span></span><br><span class="line"><span class="comment">// 好处2：将对象构建的过程，封装在了director里面，director来基于builder进行构建，构建逻辑修改，不需要修改很多地方</span></span><br><span class="line"><span class="comment">// 好处3：相对于工厂，有一个很好的抽象设计，director和builder</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> String field1;</span><br><span class="line">       <span class="keyword">private</span> String field2;</span><br><span class="line">       <span class="keyword">private</span> String field3;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getField1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> field1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField1</span><span class="params">(String field1)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.field1 = field1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getField2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> field2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField2</span><span class="params">(String field2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.field2 = field2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getField3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> field3;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField3</span><span class="params">(String field3)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.field3 = field3;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;Product [field1=&quot;</span> + field1 + <span class="string">&quot;, field2=&quot;</span> + field2 + <span class="string">&quot;, field3=&quot;</span> + field3 + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">field1</span><span class="params">(String value)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">field2</span><span class="params">(String value)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">field3</span><span class="params">(String value)</span></span>;</span><br><span class="line">       <span class="function">Product <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">field1</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;在设置field1之前进行复杂的校验逻辑&quot;</span>);  </span><br><span class="line">           product.setField1(value); </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">field2</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;在设置field2之前进行复杂的数据格式转化逻辑&quot;</span>);  </span><br><span class="line">           product.setField2(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">field3</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联&quot;</span>);</span><br><span class="line">           product.setField3(value);  </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> product;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * director是面向builder的接口，来编程的</span></span><br><span class="line"><span class="comment">    * director可以复杂控制构建的一个步骤，具体的每个步骤的逻辑封装在具体的builder类中</span></span><br><span class="line"><span class="comment">    * 如果我们此时要更换一整套的构建逻辑，可以再搞一个新的builder类就可以了</span></span><br><span class="line"><span class="comment">    * 但是我们的整个构建步骤是没有任何改变的</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 如果整个构建步骤变化了，但是对构建的逻辑是没有影响的</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.builder = builder;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">(String field1, String field2, String field3)</span> </span>&#123;</span><br><span class="line">           builder.field1(field1);</span><br><span class="line">           builder.field2(field2);</span><br><span class="line">           builder.field3(field3);  </span><br><span class="line">           <span class="keyword">return</span> builder.create();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="优化后的代码"><a href="#优化后的代码" class="headerlink" title="优化后的代码"></a>优化后的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将构造的过程掌握在调用者手中</span></span><br><span class="line">Product product = <span class="keyword">new</span> ConcreteBuilder()</span><br><span class="line">.field1(<span class="string">&quot;值1&quot;</span>)</span><br><span class="line">.field2(<span class="string">&quot;值2&quot;</span>)</span><br><span class="line">.field3(<span class="string">&quot;值3&quot;</span>)</span><br><span class="line">.create();</span><br><span class="line">System.out.println(product);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在基本上流行的一些开源框架，构造器模式的运用，一般都是上面这种变种模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String field1;</span><br><span class="line"><span class="keyword">private</span> String field2;</span><br><span class="line"><span class="keyword">private</span> String field3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getField1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> field1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField1</span><span class="params">(String field1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.field1 = field1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getField2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> field2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField2</span><span class="params">(String field2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.field2 = field2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getField3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> field3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField3</span><span class="params">(String field3)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.field3 = field3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Product [field1=&quot;</span> + field1 + <span class="string">&quot;, field2=&quot;</span> + field2 + <span class="string">&quot;, field3=&quot;</span> + field3 + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Builder <span class="title">field1</span><span class="params">(String value)</span></span>;</span><br><span class="line"><span class="function">Builder <span class="title">field2</span><span class="params">(String value)</span></span>;</span><br><span class="line"><span class="function">Builder <span class="title">field3</span><span class="params">(String value)</span></span>;</span><br><span class="line"><span class="function">Product <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">field1</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;在设置field1之前进行复杂的校验逻辑&quot;</span>);  </span><br><span class="line">product.setField1(value); </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">field2</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;在设置field2之前进行复杂的数据格式转化逻辑&quot;</span>);  </span><br><span class="line">product.setField2(value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">field3</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;在设置field3之前进行复杂的数据处理逻辑，跟其他对象的数据进行关联&quot;</span>);</span><br><span class="line">product.setField3(value);  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构造器模式&quot;&gt;&lt;a href=&quot;#构造器模式&quot; class=&quot;headerlink&quot; title=&quot;构造器模式&quot;&gt;&lt;/a&gt;构造器模式&lt;/h2&gt;&lt;p&gt;建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之外观模式</title>
    <link href="https://devloperhu.gitee.io/posts/54086.html"/>
    <id>https://devloperhu.gitee.io/posts/54086.html</id>
    <published>2021-03-28T14:28:53.000Z</published>
    <updated>2021-12-12T15:55:00.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p><p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p><p>比如说service就是一个经典的门面模式。如果一个子系统里有多个DAO组件，然后如果别的子系统要实现一段业务逻辑，需要使用这个子系统的多个DAO组件，那就会导致别的子系统代码会很乱，需要care这个子系统很多DAO组件的实现。但是这个组件可以基于多个DAO组件封装出来一个service接口，然后别的系统就针对一个service接口开发即可。这个service不就是一个典型的门面吗？</p><p><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModuleA</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleAImpl</span> <span class="keyword">implements</span> <span class="title">ModuleA</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现模块A的功能&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModuleB</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleBImpl</span> <span class="keyword">implements</span> <span class="title">ModuleB</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现模块B的功能&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModuleC</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleCImpl</span> <span class="keyword">implements</span> <span class="title">ModuleC</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现模块C的功能&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemAFacade</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModuleA moduleA = <span class="keyword">new</span> ModuleAImpl();</span><br><span class="line">        moduleA.operate();</span><br><span class="line">        </span><br><span class="line">        ModuleB moduleB = <span class="keyword">new</span> ModuleBImpl();</span><br><span class="line">        moduleB.operate();</span><br><span class="line">        </span><br><span class="line">        ModuleC moduleC = <span class="keyword">new</span> ModuleCImpl();</span><br><span class="line">        moduleC.operate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemB</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SystemA.operate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h2&gt;&lt;p&gt;外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属</summary>
      
    
    
    
    <category term="设计模式" scheme="https://devloperhu.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java基础" scheme="https://devloperhu.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
